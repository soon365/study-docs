

# 1.构造方法和方法重载

如:
Person p=new Person();p.show();
声明Person类型的引用指向Person类型的对象使用引用变量p调用show方法1.1构造方法（重中之重）

(1)语法格式
class类名{
类名（形参列表）{

构造方法体；

}

}

如：
class Person{

Person （）{

}

}
(2)注意事项
a.构造方法的名称与类名完全相同，没有返回值类型连void都不许有。
b.

(3)默认构造方法

a.当一个类中没有自定义任何形式的构造方法时，编译器会自动添加一个无参的空构造方法，叫做默认/缺省构造方法，如:Person(){}

b.若类中出现自定义构造方法，则编译器不再提供任何形式的构造方法。

public class Person {
    private String name;
    private int age;

    // 有参构造方法
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Getter方法
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
}

1.2方法的重载(0verload 会用即可)

(1)基本概念在Java语言中若方法的名称相同但参数列表不同，这样的方法之间构成重载关系。
(2)体现形式方法重载的主要形式有:参数的个数不同、参数的类型不同、参数的顺序不同，与形参变量名和返回值类型无关，但建议返回值类型最好相同。判断方法是否重载的核心:调用能否区分。

(3)实际意义
对于调用者来说只需要记住一个方法名就可以调用各种不同的版本实现不同的效果。
char cSystem.out.println(c),int i = 10;System.out.println(i),double d=3.14,System. out. println(d)

# 2.this关键字(原理、理解)

2.1 基本概念
在构造方法中this关键字代表当前正在构造的对象在成员方法中this关键字代表当前正在调用的对象。

原理分析:
当成员方法中访问成员变量时默认会加上this.(相当于汉语中"我的")，当不同的引用调用同一个成员方法时会导致成员方法中的this不同，那么this.访问的结果随之不同。

2.2使用方式

(1)当形参变量和成员变量同名时，在构造方法或成员方法中通常优先使用形参变量，若希望使用成员变量就需要在变量名的前面加上this.进行说明(重中之重)。

(2)在构造方法的第一行使用this(实参)的方式可以调用本类中的其它构造方法(了解)

示例：

public class ThisExample {
    private String name;
    
    // 使用this区分成员变量和参数
    public ThisExample(String name) {
        this.name = name;
    }
    
    // 使用this调用当前类的方法
    public void printName() {
        System.out.println("Name: " + this.getName());
    }
    
    public String getName() {
        return this.name;  // 这里的this是可选的
    }
    
    public static void main(String[] args) {
        ThisExample example = new ThisExample("Test");
        example.printName();
    }
}

# 3.方法的传参和递归调用

3.1方法的传参过程(理解)
(1)main方法是程序的入口，为main方法中的局部变量开辟内存空间并初始化;

(2)调用max方法时为max方法的形参变量开辟内存空间;

(3)使用实参变量给形参变量进行赋值操作，执行max方法的方法体;

（4)当max方法结束盾释放形参变量的内存空间;

(5)main方法中的res得到max方法的返回值然后继续向下执行;

（6）当main方法结束后释放局部变量的内存空间;

要求大家掌握的内容:
a.当基本数据类型的变量作为方法的参数传递时，形参变量的改变不会影响到实参

b.当引用数据类型的变量作为方法的参数传递时，形参变量指向的内容发生改变后会影响到实参变量指向的内容;

c.当引用数据类型的变量作为方法的参数传递时，形参变量改变指向后再改变指向的内容时不会影响到实参变量指向的内容;

示例：public class ReferenceDemo {
    public static void main(String[] args) {
        // 对象引用示例
        Person p1 = new Person("Alice");
        Person p2 = p1;  // p2和p1引用同一个对象
        p2.setName("Bob");
        System.out.println("p1 name: " + p1.getName());  // 输出Bob
        
        // 数组引用示例
        int[] arr1 = {1, 2, 3};
        int[] arr2 = arr1;  // arr2和arr1引用同一个数组
        arr2[0] = 100;
        System.out.println("arr1[0]: " + arr1[0]);  // 输出100
        
        // 方法参数引用传递
        modifyArray(arr1);
        System.out.println("After modify: " + arr1[0]);  // 输出999
    }
    
    static void modifyArray(int[] arr) {
        arr[0] = 999;
    }
}

class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

.2 递归调用(1)基本概念
在一个方法体的内部调用当前方法自身的形式，叫做递归。
如:
void show(){show();
案例:自定义成员方法实现参数n阶乘的计算并返回:解析:
5！= 5 * 4 * 3 * 2 * 1；

4！ = 4 * 3 * 2 * 1；

3！=3 * 2 * 1；

2！ =2*1；

1！=1；

2)注意事项
a.必须找到递归的规律和退出条件;b.使用递归使得问题简单化而不是复杂化:c.若递归影响到程序的执行性能则使用递推取代之

示例：

public class FactorialDemo {
    // 递归方法计算阶乘
    public static int factorial(int n) {
        if (n == 0 || n == 1) {  // 基线条件
            return 1;
        } else {
            return n * factorial(n - 1);  // 递归调用
        }
    }
    
    public static void main(String[] args) {
        int number = 5;
        System.out.println(number + "的阶乘是: " + factorial(number));
    }
}
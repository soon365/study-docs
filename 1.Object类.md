1.Object类

1.1常用的包

java.lang包-该包是Java语言中的核心包，该包中的内容由Java虚拟机自动导入
-如:String类、System类等
java.util包-该包是Java语言中的工具包，里面包含了大量的工具类和集合类等
-如：Scanner类、Random类等
java. io包
一该包是Java语言中的输入输出包，里面包含了大量读写文件的类等
-如：FileOutputStream类、FileInputStream类等
java.net包一该包是Java语言中的网络包，里面包含了大量网络编程的类等
-如：ServerSocket类、Socket类等

1.2	Object类

(1)基本概念
java.lang.Object类是所有类层次结构的根类，任何类都是该类的直接或间接子类。
(2)常用的方法
Object （）-使用无参方式构造对象。

boolean equals(Object obj)
用于判断调用对象是否与参数对象相等。

—该方法默认比较两个对象的地址，与==运算符结果相同。

一为了使得该方法比较两个对象的内容，则需要重写该方法。

—若该方法重写后，则应该重写hashCode方法来维护hashCode方法的常规协定

inthashCode(-用于获取调用对象的哈希码值（内存地址的编号)。
—若调用equals方法的结果相等，则各自调用hashCode方法的结果相同。
一若调用equals方法的结果不相等，则各自调用hashCode方法的结果不相同。

—为了维护上述的常规协定与equals方法结果保持一致，就需要重写该方法

String toString（）一用于获取对象的字符串形式。
一该方法默认返回的字符串为：包名.类名@哈希码值的十六进制形式

—为了返回更有意义的数据内容则需要重写该方法

一当字符串内容与引用进行连接时，自动调用toString（）方法

当使用print或println方法打印引用时，会自动调用toString（）方法

2. 包装类和数学处理类（会用即可)
如:
Personp=newPersonO；-声明Person类型的引用指向Person类型的对象
int num = 10;
-声明一个int类型的变量num初始值为10
Java语言是一门纯面向对象的编程语言
2.1包装类的概念
由于Java语言是一门纯面向对象编程语言，而8种基本数握类型声明的变量并不是对象，为了满足Java语言的特性就需要对这些变量进行对象化处理，而实现该功能的相关类就
叫做包装类。
2.2包装类的分类

	int => java. lang. Integer类
char => java.lang.Character类
其它类型对应的包装类就是将首字母变成大写

2.3 Integer类
（1)基本概念
java.lang.Integer类是int类型的包装类，里面包含了一个int类型的成员变量。
该类由final关键字修饰表示不能被继承。
(2)常用的方法
Integer(intvalue)－根据参数指定的整数构造对象
Integer(Strings)一根据参数指定的字符串构造对象

该类重写了equalsO、hashCode(）、toString（）方法

intintValue(-用于获取调用对象中的整数数据并返回。
staticIntegervalueOf(inti)-根据参数指定的整数返回对应的Integer对象。
staticintparseInt(Strings)-用于将String类型转换为int类型并返回。

2.4 BigDecimal类
（1）基本概念
由于float类型和double类型的运算可能会有误差，为了实现精确运算则需要借助
java. math.BigDecimal类型加以描述。
(2)常用的方法
BigDecimal(Stringval)-根据参数指定的字符串构造对象。
BigDecimal add (BigDecimal augend)
一用于计算调用对象和参数对象的和并返回
BigDecimalsubtract(BigDecimalsubtrahend)-用于计算调用对象和参数对象的差
并返回。

BigDecimal multiply(BigDecimal multiplicand)
一用于计算调用对象和参数对象的积并返回。
BigDecimal divide(BigDecimal divisor)

—用于计算调用对象和参数对象的商并返回。

3. String类（重中之重)
3.1基本概念
java.lang.String类用于描述字符串，Java应用程序中所有字符串字面值都可以作为
String类型的对象加以描述，如：”abc”等。
该类描述的字符串内容是个常量，一旦创建完毕后则不能更改，因此可以被共享。
如:
String strl = "abc";

​	strl = "123”;—改变str1的指向而不是指向的内容

3.2常量池（原理、尽量理解）
由于String类型描述的字符串内容是个常量不可改变，因此Java虚拟机提供了一个常
量池，当Java程序中出现字符串内容时就放入常量池中，若后续出现重复的字符串内容则
直接使用池中已有的对象而不需再次创建，从而提高了性能。

示例：

public class StringDemo {
    private String value;

    // 无参构造方法
    public StringDemo() {
        this.value = "";
    }
    
    // 带参构造方法
    public StringDemo(String value) {
        this.value = value;
    }
    
    // 字符数组构造方法
    public StringDemo(char[] charArray) {
        this.value = new String(charArray);
    }
    
    // 字节数组构造方法
    public StringDemo(byte[] bytes) {
        this.value = new String(bytes);
    }
    
    @Override
    public String toString() {
        return value;
    }
}

3.3String 类的常用方法（重中之重、熟练、）

4.String Builder类和StringBuffer类（重点）

如：
String strl = "ab”;
String str2 ="abc“；
String str3 ="abcd"；

4.1基本概念

由于String类型描述的字符串内容是个常量不可更改，当程序中出现大量类似的字符
串时需要单独存放从而浪费内存空间，若希望使用一块内存空间进行存储并且可以修改字
符串内容，则应该使用StringBuilder类和StringBuffer类。

其中StringBuffer类从jdk1.0开始存在，该类支持线程安全，因此访问的效率比较低

其中StringBuilder类从jdk1.5开始存在，该类不支持线程安全，访问的效率比较高

示例：

public class StringBuilderDemo {
    public static void main(String[] args) {
        // 1. 删除操作
        StringBuilder sb = new StringBuilder("HelloWorld");
        sb.delete(5, 10);  // 删除"World" → "Hello"
        sb.deleteCharAt(0);  // 删除'H' → "ello"
        
        // 2. 反转操作
        sb.reverse();  // "olle"
        
        // 3. 相互转换
        String str = sb.toString();  // StringBuilder转String
        StringBuilder newSb = new StringBuilder(str);  // String转StringBuilder
    }
}

5.日期相关的类

5.1 Date类
(1)基本概念
java.util. Date类用于描述特定的瞬间，可以精确到毫秒。
(2)常用的方法
5.2 SimpleDateFormat类
（1)基本概念
java.text.SimpleDateFormat类主要用于实现日期和文本之间的相关转换。
(2)常用的方法
示例：

import java.text.SimpleDateFormat;
import java.util.Date;

public class DateFormatDemo {
    public static void main(String[] args) throws Exception {
        // 创建实例并设置格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        
        // 格式化当前时间
        String dateStr = sdf.format(new Date());
        System.out.println("当前时间：" + dateStr);
        
        // 解析字符串为Date对象
        Date date = sdf.parse("2025-07-06 15:30:00");
        System.out.println("解析结果：" + date);
        
        // 修改格式模式
        sdf.applyPattern("yyyy年MM月dd日 HH时mm分");
        System.out.println("修改格式后：" + sdf.format(date));
    }
}

5.3 Calendar类
(1)基本概念
(2)常用的

6. 集合（容器)框架

   6.1集合的由来
   当需要在程序中记录单个数据内容时，则声明一个变量即可；
   当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数组即可；
   当需要在程序中记录多个类型不同的数据内容时，则构造一个对象即可；
   当需要在程序中记录多个类型相同的对象时，则声明集合

   6.2在Java语言中集合框架的顶层是：java.util.6ollection集合
   和java.util. Map集合
   其中Collection集合中操作元素的基本单位是：单个元素。
   其中Map集合中操作元素的基本单位是：单对元素

在以后的开发中很少直接使用Collection集合，而是使用该集合的子集合：List集合、
Queue集合、Set集合等。

示例：

import java.util.*;

public class CollectionDemo {
    public static void main(String[] args) {
        Collection<String> coll = new ArrayList<>();
        
        // 添加元素
        coll.add("A");
        coll.addAll(Arrays.asList("B","C"));
        
        // 查找判断
        System.out.println("包含A: " + coll.contains("A"));
        
        // 删除元素
        coll.remove("B");
        coll.removeIf(s -> s.startsWith("C"));
        
        // 判空检查
        System.out.println("集合为空: " + coll.isEmpty());
    }
}

7.Collection集合（重点)
7.1基本概念
java.util.Collection集合是集合框架的根接口，其它接口是该接口的子接口。
7.2常用的方法（练熟、记住)

8.List集合(重中之重)
8.1基本概念
java.util.List集合是Collection集合的子集合，该集合中元素有先后次序且允许重复
该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类等
其中ArrayList类的底层是采用动态数组进行数据管理，访问方便、增删不方便

其中LinkedList类的底层是采用链表进行数据管理，增删方便，访问不方便。

其中Stack类主要用出特征的数据结构，叫做栈，last in first out

该类的底层是采用数组进行数据的管理。

其中Vector类的底层采用数组进行数据的管理，与ArrayList类相比属于线程安全的类
，因此效率比较低，在以后的开发中推荐使用ArrayList类取代之。

示例：
import java.util.*;

public class ListOperationsDemo {
    public static void main(String[] args) {
        // 1. 创建List并添加元素
        List<String> list = new ArrayList<>();
        list.add("Apple");       // 单个添加
        list.add(0, "Banana");   // 指定位置添加
        list.addAll(Arrays.asList("Orange", "Grape")); // 批量添加
        
        // 2. 遍历集合
        System.out.println("=== 遍历方式 ===");
        // 方式1：for循环
        for(int i=0; i<list.size(); i++){
            System.out.println("索引"+i+": "+list.get(i));
        }
        // 方式2：增强for循环
        for(String fruit : list){
            System.out.println(fruit);
        }
        // 方式3：迭代器
        Iterator<String> it = list.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
        
        // 3. 修改元素
        list.set(1, "Mango");  // 将索引1改为Mango
        System.out.println("修改后: " + list);
        
        // 4. 删除元素
        list.remove(0);        // 按索引删除
        list.remove("Grape");  // 按元素删除
        System.out.println("删除后: " + list);
        
        // 5. 获取子集合（含头不含尾）
        List<String> subList = list.subList(0, 1);
        System.out.println("子集合: " + subList);
    }
}

9.泛型机制（重点）

9.1基本概念
通常情况下集合中可以存放不同类型的对象，本质上是将这些对象全部看做Object类
型放入的，因此从集合中取出元素时也是Object类型，为了表达元素最真实的数据类型就
需要强制类型转换，而强制类型转换可能发生类型转换异常。
为了避免上述错误的发生，从jdk1.5开始提出泛型机制，也就是在集合名称的右侧使
用<数据类型>的方式明确要求该集合可以存放的元素类型，若放入其它类型则编译报错
如：
Listltl=newLinkedListO；-可以放入任意类型对象，取出麻烦
List<String> ltl =new LinkedList<String>O;
只能放入String类型，取出方便

9.2原理分析
泛型的本质就是参数化类型，也就是让数据类型作为参数传递，集合定义中的E相当于
形式参数负责占位，而使用集合时中的数据类型相当于实际参数负责给形式参数初始化
当初始化完毕后所有E被替换为实际参数表示的类型进行使用。
如：
//其中i叫做形式参数，负责占位
其中E叫做形式参数，负责占位
/ int i=5;
E=String;
// int i = 10;
E= Student;
public void show(int i) {
public interface List<E> {
了
上
//其中5叫做实际参数，用于给形式参数初始化
其中String叫做实际参数
show (5) ;
List<String> lti = ...;
show(10);
List<Student> lt2 = ...;

10. Queue集合(重点)
    10.1基本概念
    java.util.Queue集合是Collection集合的子集合，与List集合是平级关系。
    该集合的主要实现类是：LinkedList类，因为该类在增删方面有一定的优势。
    该集合用于描述具有先进先出特征的数据结构，叫做队列(first in first out)。

    示例：

    from queue import Queue
    q = Queue()
    q.put(1)  # 入队
    q.put(2)
    print(q.get())  # 出队(输出1)
    print(q.empty())  # 判空(输出False)

11. Set集合（重点)
    11.1基本概念
    java.util.Set集合是Collection集合的子集合，与List集合以及Queue集合平级关系
    该集合与List集合的主要区别在于：元素没有先后次序并且不允许重复的元素。
    该集合的主要实现类有：HashSet类和TreeSet类。
    其中HashSet类的底层采用哈希表进行数据管理的。
    其中TreeSet类的底层采用二叉树进行数据管理的。

11.2元素放入哈希表的过程

向HashSet中放元素的次序：
1先调用元素的hashCode(方法得到哈西码，通过算法计算在哈西表中的位置
2如果该位置没有元素，直接放入即可。
3如果该位置有元素，调用元素的equals()方法比较是不是相等。
4如果相等，则保留旧元素丢弃新元素。
5如果不相等，则放入该位置的链表年一个元素。

示例：

import java.util.*;

public class SetIteratorDemo {
    public static void main(String[] args) {
        Set<String> fruitSet = new HashSet<>();
        Collections.addAll(fruitSet, "Apple", "Banana", "Orange");
        
        // 获取迭代器
        Iterator<String> iterator = fruitSet.iterator();
        
        // 遍历集合
        while(iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
        }
    }
}

示例2：

import java.util.*;

public class SetIteratorDemo {
    public static void main(String[] args) {
        Set<String> fruitSet = new HashSet<>();
        Collections.addAll(fruitSet, "Apple", "Banana", "Orange");
        
        // 获取迭代器
        Iterator<String> iterator = fruitSet.iterator();
        
        // 遍历集合
        while(iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
        }
    }
}

11.3使用迭代器实现toString

注意：
当使用迭代器迭代集合中的所有元素时，若使用集合中的remove方法来删除元素，则会
出现ConcurrentModificationException并发修改异常，以后的开发中应该使用迭代器的
emove方法来删除元素。

示例：

import java.util.*;

public class CustomCollection<T> implements Iterable<T> {
    private final List<T> elements = new ArrayList<>();

    public void add(T item) {
        elements.add(item);
    }
    
    @Override
    public Iterator<T> iterator() {
        return elements.iterator();
    }
    
    @Override
    public String toString() {
        Iterator<T> it = iterator();
        if (!it.hasNext()) return "[]";
    
        StringBuilder sb = new StringBuilder("[");
        while (true) {
            T e = it.next();
            sb.append(e == this ? "(this Collection)" : e);
            if (!it.hasNext()) return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }
    
    public static void main(String[] args) {
        CustomCollection<String> coll = new CustomCollection<>();
        coll.add("A");
        coll.add("B");
        System.out.println(coll); // 输出格式: [A, B]
    }
}

11.4增强版的for循环（for each结构）

(1)语法格式
for(元素类型变量名：数组名/集各名)
循环体；
了
(2)执行流程
不断地从数组或集合中取出一个元素并赋值给变量并执行循环体，直到处理完毕所有
元素为止。

总结：
遍历Set集合的方式有三种：toStringO、foreach结构、迭代器方式
遍历List集合的方式有四种：除了上述3种方式外，还有get方法。

12. Map集合（重点)
    12.1基本概念
    java,util.Map<K,Y>集合中操作元素的基本单位是：单对元素，其中类型参数：

    K-此映射所维护的键的类型
    V-映射值的类型

该集合中不允许出现重复的键，每个键最多只能映射到一个值。

该集合的主要实现类有：HashMap类和TreeMap类。
其中HashMap类的底层是采用哈希表进行数据管理的。

示例：

import java.util.*;

public class MapDemo {
    public static void main(String[] args) {
        // 1. 创建Map集合
        Map<String, Integer> map = new HashMap<>();
        
        // 2. 添加元素
        map.put("Apple", 10);
        map.put("Banana", 20);
        map.put("Orange", 15);
        System.out.println("初始Map: " + map);
        
        // 3. 修改元素
        map.put("Banana", 25); // 自动覆盖旧值
        System.out.println("修改后: " + map);
        
        // 4. 查找元素
        System.out.println("查找Apple: " + map.get("Apple"));
        System.out.println("包含Pear? " + map.containsKey("Pear"));
        
        // 5. 删除元素
        map.remove("Orange");
        System.out.println("删除后: " + map);
        
        // 6. 遍历方式
        System.out.println("\n遍历方式1：键值对遍历");
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " => " + entry.getValue());
        }
        
        System.out.println("\n遍历方式2：键集合遍历");
        for (String key : map.keySet()) {
            System.out.println(key);
        }
        
        System.out.println("\n遍历方式3：值集合遍历");
        for (Integer value : map.values()) {
            System.out.println(value);
        }
        
        System.out.println("\n遍历方式4：迭代器遍历");
        Iterator<Map.Entry<String, Integer>> it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Integer> entry = it.next();
            System.out.println(entry.getKey() + " :: " + entry.getValue());
        }
    }
}

13.异常机制(重点、简单)
13.1基本概念
异常就是”不正常”的含义，在Java语言中用于表示运行阶段发生的错误。
java.lang.Throwable类是Java语言中所有错误（Error)和异常（Exception)的超类。
其中Error类主要用于描述比较严重无法编码解决的问题，如：JVM挂了。
其中Exception类主要用于描述比较轻微可以编码解决的问题，如：0作为除数。
14.2基本分类
java.lang.Exception类是所有异常类的超类，主要分为以下两大类：
RuntimeException一运行时异常，也叫作非检测性异常[
IOException和其它异常一其它异常，也叫作检测性异常
一所谓检测性异常就是在编译阶段能够被编译器检测出来的异常

其中RuntimeException类的主要子类：
ArithmeticException-算术异常
ArrayIndexOutOfBoundsException 数组下标越界异常

NullPointerException-空指针异常
ClassCastException-类型转换异常
NumberFormatException-数字格式异常



注意：
当程序执行过程中发生异常但没有手动处理时，由Java虚拟机采用默认方式处理，而
默认处理方式就是：打印异常名称、异常原因、异常发生的位置等并终止程序。

14.3异常的避免

在以后的开发中尽量使用if条件判断来避免异常的发生

14.4异常的避免

（1)语法格式
try{
编写可能发生异常的语句；
}catch(异常类型 变量名){
针对该类异常的处理语句；
}

finally {
编写无论是否发生异常都应该执行的语句；

}

示例：

try:
    num = int("abc")  # 触发ValueError
except ValueError as ve:
    print(f"值错误: {ve}")
except Exception:
    print("未知错误")
else:
    print("未发生异常时执行")
finally:
    print("始终执行")

（2）注意实现

a.当需要编写多个catch分支时，切记小类型的异常应该放在大类型异常的上面。
懒人的写法：
catch(Exception e){........}

b.finally主要用于编写善后处理的语句，如：关闭已经打开的文件等


14.5异常的抛出

（1)基本概念
在某些特殊情况下产生的异常无法处理或者不便于处理时，就可以将该异常转移给该
方法的调用者，这种方式就叫做异常的抛出。

（2）语法格式

访问权限  返回值类型  方法名称（形参列表）throws 异常类型1，异常类型2，.....{}

如：public void show（） throws IOException{}

(3)方法重写的原则
a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型
b.要求方法的访问权限不能变小，可以相同或者变大
c.要求不能抛出更大的异常

14.6自定义异常
（1)基本概念
虽然Java官方提供了大量的异常类，但一定不会包含所有开发中可能出现的异常，在
Java程序中若需要使用表达特定问题的特定异常时，就需要程序员自定义异常来描述。

（2)实现流程
a.自定义xxxxException继承自Exception类或者其子类；
b.提供两个版本的构造方法：无参构造方法和字符串作为参数的构造方法；

示例：

// 示例：自定义业务异常类
public class BusinessException extends RuntimeException {
    private String errorCode;
    
    public BusinessException() {
        super();
    }
    
    public BusinessException(String message) {
        super(message);
    }
    
    public BusinessException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}

15.File类

15.1基本概念
java.io.File类主要用于描述文件和目录的路径信息，可以获取名称、大小等属性信息
15.2常用的方法

绝对路径一主要指以根目录开始的路径信息，如：c：/···
d:/..
/.
相对路径-主要指以当前工作目录开始的路径信息，如：·/..
：表示当前目录
.表示当前目录的上一级目录
—在以后的开发中尽量使用相对文件

示例：

import java.io.File;
import java.util.Arrays;

public class FileOperations {
    // 创建文件
    public static boolean createFile(String filePath) {
        try {
            File file = new File(filePath);
            return file.createNewFile();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // 删除文件
    public static boolean deleteFile(String filePath) {
        File file = new File(filePath);
        return file.delete();
    }
    
    // 创建目录
    public static boolean createDir(String dirPath) {
        File dir = new File(dirPath);
        return dir.mkdirs();  // mkdirs()会创建所有不存在的父目录
    }
    
    // 删除目录（空目录）
    public static boolean deleteEmptyDir(String dirPath) {
        File dir = new File(dirPath);
        return dir.delete();
    }
    
    // 递归删除目录及其内容
    public static boolean deleteDirRecursive(String dirPath) {
        File dir = new File(dirPath);
        if (!dir.exists()) return false;
        
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    deleteDirRecursive(file.getAbsolutePath());
                } else {
                    file.delete();
                }
            }
        }
        return dir.delete();
    }
    
    // 获取目录内容
    public static void listDirectory(String dirPath) {
        File dir = new File(dirPath);
        if (!dir.exists() || !dir.isDirectory()) {
            System.out.println("目录不存在或不是有效目录");
            return;
        }
        
        System.out.println("目录内容:");
        File[] files = dir.listFiles();
        if (files != null) {
            Arrays.stream(files).forEach(file -> {
                System.out.println((file.isDirectory() ? "[目录] " : "[文件] ") 
                    + file.getName());
            });
        }
    }
    
    public static void main(String[] args) {
        // 测试示例
        String dirPath = "testDir";
        String filePath = dirPath + "/testFile.txt";
        
        createDir(dirPath);
        createFile(filePath);
        listDirectory(dirPath);
        deleteFile(filePath);
        deleteDirRecursive(dirPath);
    }
}

16 IO流

16.1基本概念

I/0就是Input/Output的简写，也就是输入输出的含义。
I/0流就是像流水一样不间断地进行输入输出的状态

16.2 基本分类
按照数据读写的基本单位不同分为字节流和字符流。
其中字节流主要指以字节为单位进行读写的流，可以处理任意类型的文件；
其中字符流主要指以字符（2个字节)为单位进行读写的流，只能处理文本文件；

按照数据流动的方向不同分为：输入流和输出流（站在程序的角度）。

基中输入流主要指从文件中读取数据内容输入到程序中，也就是读文件；
其中输出流主要指将程序中的数据内容输出到文件中，也就是写文件；

16.3 FileOutputStream类（重中之重)
(1)基本概念
java.io.FileOutputStream类主要用于将图像数据之类的原始字节流写入输入流中
(2)常用的方法

1. ‌**write(int b)**‌
   写入单个字节（参数的低8位）到输出流‌
2. ‌**write(byte[] b)**‌
   将整个字节数组写入输出流‌
3. ‌**write(byte[] b, int off, int len)**‌
   从字节数组的off位置开始写入len长度的数据‌
4. ‌**close()**‌
   关闭流并释放系统资源（必须调用防止资源泄漏）‌
5. ‌**getChannel()**‌
   返回与此流关联的FileChannel对象‌
6. ‌**getFD()**‌
   返回文件描述符‌5

关键特性说明：

- 构造方法支持追加模式（通过参数append=true实现）‌
- 写入操作会自动创建不存在的文件（需有目录权限）‌
- 默认会覆盖已有文件内容，除非显式启用追加模式‌

典型使用场景包括文件拷贝‌6、日志追加‌1等需要字节级文件输出的场景。注意要配合try-with-resources或finally块确保流关闭
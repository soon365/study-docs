# Java基础

## 一、计算机的基本概念

计算机(Computer)俗称电脑，是现代一种用于高级计使用非常广泛的设备。

### 计算机的组成

**计算机硬件和计算机软件两个部分组成**

(1)计算机硬件是客观存在的各种计算机相关设备。

计算机中常见的硬件有:CPU、内存、硬盘、显卡、键盘、显示器、鼠标...

​	CPU：中央处理器,是计算机中最核心的部件，相当于人的大脑。主要用于处理各种计算机的指令以及软件中的数据等。

​	内存：是计算机中的存储部件。主要用于临时存放CPU访问的数据内容，，CPU直接访问且效率高容量小，一旦断电会造成数据的丢失。

​	硬盘：是计算机中的存储部件-CPU不能直接访问硬盘中的数据，因此效率比较低。-容量大，若断电不会造成数据的丢失。其中键盘叫做标准输入设备，显示器叫做标准输出设备

(2)计算机的软件是用于控制各种硬件设备完成各种功能。

**常见的计算机软件:**
	计算中常见的软件主要分为两部分:系统软件和用软其中系统软件主要指操作系统，主流操作系统:Windows/Unix/Linux/ios/Android

​	其中应用软件主要指安装在操作系统之上的软件:QQ、迅雷、火狐浏览器...

### 计算机的机体结构

使用者=>应用软件=>系统软件(内核(Kernel)和外壳(Shell))=>硬件设备



![image-20250629113810356](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250629113810356.png)

## 二、Java语言的概述

### Java语言的背景

​	Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。

**Java分为三个体系：**

- JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）
- JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)
- JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。

​	2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 "2"：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。

### 开发环境的搭建和使用

###  jdk的下载和安装

**下载方式**

1. 访问Oracle官网：首先，打开浏览器，访问Oracle官方网站（[https://www.oracle.com/](https://www.oracle.com/），在导航栏中找到“Downloads”（下载）选项，点击进入。)），在导航栏中找到“Downloads”（下载）选项，点击进入。
2. 选择JDK版本：在Downloads页面中，选择适合你操作系统的JDK版本，例如Windows、macOS或Linux，并点击下载链接。
3. 接受许可协议：在下载页面中，你需要接受Oracle的许可协议，仔细阅读协议内容后，勾选“Accept License Agreement”（接受许可协议）并点击下载链接。
4. 下载JDK：下载JDK安装包。

**安装方式**

1. Windows系统：在下载完成后，双击下载的JDK安装包，按照提示完成JDK的安装。
2. macOS系统：在下载完成后，双击下载的JDK安装包，按照提示完成JDK的安装。
3. Linux系统：在下载完成后，打开终端，使用命令行安装JDK。具体安装方式可以根据不同Linux发行版有所区别，建议查阅相应的文档或官方网站获取安装指南。

若下载的是绿色版，则直接解压即可

若下载的是安装版，则直接一路点击下一步即可

切记jdk的安装路径中不要有中文!

### 相关的概念

jdk- Java开发工具包，只要做Java开发就需要下载和安装该软件。

jre-Java运行时环境信息，只要运行Java程序就需要下载和安装该软件。

jvm-Java虚拟机，是Java程序与计算机操作系统之间的桥梁。

javac.exe-Java语言的编译器，主要用于将Java源代码进行编译生成字节码文件。

java.exe- Java语言的解释器，主要用于启动Java虚拟机对字节码文件进行解释执行。

## 三、Java程序的编写

### Java程序的编写流程

(1)新建文本文档，将文件名由xxx.txt修改为xxx.java;

(2)使用记事本的方式打开文件，编写Java代码后进行保存;

(3)启动dos窗口，切换到xxx.java文件所在的路径中;

(4)使用javac xxx.java进行编译，生成xxx.class的字节码文件;

(5)使用java xxx进行解释执行，打印最终结果;

**快捷键**：

windows+r 打开运行，输入cmd后回车就可以启动dos窗口

### 环境变量的配置

**基本概念**

​	通常情况下可执行文件只能在该文件所在的路径中访问，若希望该可执行文件可以在任意路径中使用则需要将该可执行文件的路径信息配置到环境变量Path中。

**实现方式**

​	计算机=〉右键，选择属性=〉高级系统设置=>高级=〉环境变量=〉系统变量=>找到Path，点击编辑=>将javac.exe所在的路径信息复制到Path变量值的最前面，加上英文版的分号=>一路点击确定即可切记Path变量值原来的内容不要改变，配置完毕后重新启动dos窗口!

Java的编译与运行：

![image-20250629142934264](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250629142934264.png)

### java跨平台原理

​	Java字节码可以通过JVM翻译为具体平台能够执行的机器指令。由于Sun定义了JVM规范，而且不同的操作系统大多提供了JVM实现，才使得相同的一个字节码文件可以在不同的系统上运行，从而使Java赢得了“一次编译，到处使用”的美名。

## 四、Java语言的基础语法格式

### 变量和注释

#### 基本概念

当需要在Java程序中记录单个数据内容时，则声明一个变量即可，而声明变量的本质就是在内存空间中申请一块存储单元，由于该存储单元的数值可以发生改变，因此得名为变量"。

由于存放数据内容的大小不同导致所需存储单元的容量不同，在Java语言中使用数据类型加以描述，为了便于下次访问还需要指定变量的名称。

用于指代内存中的一块存储区域。
变量必须有特定的数据类型，不同的数据类型表示不同的数据存储结构。
每个变量都有自己的作用范围，叫作用域。

![image-20250629144356554](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250629144356554.png)

#### 声明方法

数据类型：变量名=初始值

![image-20250629144922114](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250629144922114.png)

 **标识符**

Java语言中的类名、对象名、方法名、常量名和变量名统称为标识符。

为了提高程序的可读性，在定义标识符时，要尽量遵循“见名知意”的原则。

Java标识符的具体命名规则如下：

- (1)标识符由一个或多个字母、数字、下划线(_)和美元符号($)组成，没有长度限制，尽量使用有意义的英文单词来定义标识符。
- (2)一个标识符可以由几个单词连接而成，以表明它的意思。
- (3)标识符中的第一个字符不能为数字。
- (4)标识符不能是关键字。
- (5)标识符不能是true、false 和null。
- (6)类名的每个单词的首字母都要大写，其他字母则小写，如 Student。
- (7)方法名和变量名除了第一个单词的首字母小写外，其他单词的首字母都要大写，如studentName 。
- (8)常量名的每个单词的每个字母都要大写，如果由多个单词组成，通常情况下单词之间用下画线(_)分隔，如 MIN_VALUE。
- (9)包名的每个单词的每个字母都要小写，如cn.itcast. test。

#### 注释

**定义**:用于解释说明程序的文字

**分类**

- 单行注释

  格式://注释文字

- 多行注释

  格式:/注释文字 */

- 文档注释

  格式:/**注释文字 */

**作用**
在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。
注意事项:多行和文档注释都不能嵌套使用。

###  Java的数据类型

**定义:**Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。
**分类**

- 基本数据类型

​	数值型
​		整数类型(byte,short,int,long)
​		浮点类型(float,double)
​	字符型(char)
​	布尔型(boolean)

- 引用数据类型

​	类(class)
​	接囗(interface)
​	数组([])

**byte：**

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

**short：**

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

**int：**

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

**long：**

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**；
- 例子： **long a = 100000L**，**long b = -200000L**。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

**float：**

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

**double：**

- double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；

- 浮点数的默认类型为 double 类型；

- double类型同样不能表示精确的值，如货币；

- 默认值是 **0.0d**；

- 例子：

  ```
  double   d1  = 7D ;
  double   d2  = 7.; 
  double   d3  =  8.0; 
  double   d4  =  8.D; 
  double   d5  =  12.9867; 
  ```

  7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。

**boolean：**

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。

**char：**

- char 类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（十进制等效值为 0）；
- 最大值是 **\uffff**（即为 65535）；
- char 数据类型可以储存任何字符；
- 例子：char letter = 'A';。

#### 类型默认值

- `int`, `short`, `long`, `byte` 的默认值是0。
- `char` 的默认值是 `\u0000`（空字符）。
- `float` 的默认值是 `0.0f`。
- `double` 的默认值是 `0.0d`。
- `boolean` 的默认值是 `false`。
- 引用类型（类、接口、数组）的默认值是 `null`。

### 常用的进制

- 二进制:
  	二进制是Binary，简写为B
  	由0和1两个数字组成。
- 八进制:
  	八进制是Octal，简写为O
  	由0-7数字组成，为了区分与其他进制的数字区别，开头都是以0开始

- 十进制:
  	十进制是Decimal，简写为D
  	都是以0-9这九个数字组成。
- 十六进制:
  	十六进制为Hexadecimal，简写为H
  	表示方式为0x开头
  	计数到F后，再增加1个，就进位。
  	由0-9和A-F组成，英文字母A，B，C，D，E，F分别表示数字10~15。

#### 整数转换

**十进制转R进制**
(1)十进制转二进制的原理:

十进制数除以2，余数为权位上的数，得到商继续除以2，直到商为0终止，然后反向取余数。
具体实现:
例如(67)10→(1000011)2
将67除以2得商33，余数1。将商(33)作为第二次的被除数一次类推，直到商为0。

![image-20250630161709955](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630161709955.png)

(2)十进制转八、十六进制的原理:

跟十转二原理一样，十进制数除以8/16，余数为权位上的数得到商继续除以8/16，直到商为0终止，然后反向取余数。
具体实现:
例758(十进制)→ 1366(八进制)      951(十进制)→>3B7(十六进制)
步骤跟十进制转二进制一样。

![image-20250630161820682](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630161820682.png)

**R进制转十进制**

方法:把R进制数按权展开、相加即得十进制数。

![image-20250630162010350](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162010350.png)

例题: 1001 0110B=（）D

如下图所示，答案为150D

![image-20250630162107921](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162107921.png)

**二进制转八进制、十六进制**
方法:3位二进制数按权展开相加得到1位八进制数。(注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0)。

![image-20250630162228771](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162228771.png)

同理，二进制转十六进制时，4位二进制数按权展开相加得到1位十六进制数，不足四位补0。

![image-20250630162319061](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162319061.png)

**八进制转二进制**
方法:八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。

![image-20250630162404579](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162404579.png)

同理，十六进制转二进制也是一样的方法

#### 小数转换

**十进制转R进制**
方法:十进制小数转换成R进制小数采用“乘R取整，顺序输出“
例题:0.618D=B(精确到小数点后3位)如下所示，0.68乘以2，取整，然后再将小数乘以2，取整，直到达到题目要求精度。得到结果:0.101B.

![image-20250630162545207](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162545207.png)

同理十进制转八进制、十六进制也是一样的做法。

**R进制转十进制**
方法:把R进制数按权展开、相加即得十进制数。(具体操作如下)

![image-20250630162635479](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250630162635479.png)

小数转换跟普通转换类似，小数点后幕次就变成了负的。

## 五、运算符与表达式

### 运算符

在Java编程语言中，运算符用于执行数据的运算。Java中的运算符可以分为几类，包括算术运算符、关系运算符、位运算符、逻辑运算符、赋值运算符和其他运算符。

#### 算术运算符

算术运算符用于执行基本的数学运算，如加法、减法、乘法、除法和取模。例如，如果有两个整数变量A和B，其中A的值为10，B的值为20，则可以使用以下算术运算符：

- 加法（+）: *A + B* 结果为30。
- 减法（-）: *A - B* 结果为-10。
- 乘法（*）: *A \* B* 结果为200。
- 除法（/）: *B / A* 结果为2。
- 取模（%）: *B % A* 结果为0。
- 自增（++）: *B++* 或 *++B* 结果为21。
- 自减（--）: *B--* 或 *--B* 结果为19。

**注意事项:**

(1)在Java语言中两个整数相除时，结果只保留整数部分丢弃小数部分。

(2)若希望保留小数部分，则处理方式如下:

​	a.将其中任意一个操作数强转为double类型进行运算即可；

​	b.让其中任意一个操作数乘以1.0后进行运算即可(推荐);

(3)0不能做除数，0.0可以做除数但结果是无穷。

(4)+既可以作为算术运算符也可以作为字符串连接符，区分方式如下:

只要+两端的操作数中有一个是字符串类型，则按照字符串连接符对待。

#### 关系运算符

关系运算符用于比较两个操作数之间的关系，例如：

- 等于（==）: *A == B* 结果为false。
- 不等于（!=）: *A != B* 结果为true。
- 大于（>）: *A > B* 结果为false。
- 小于（<）: *A < B* 结果为true。
- 大于等于（>=）: *A >= B* 结果为false。
- 小于等于（<=）: *A <= B* 结果为true。

#### 位运算符

位运算符用于对整数类型的变量进行位操作，例如：

- 按位与（&）: *A & B* 结果为12。
- 按位或（|）: *A | B* 结果为61。
- 按位异或（^）: *A ^ B* 结果为49。
- 按位取反（~）: *~A* 结果为-61。
- 左移（<<）: *A << 2* 结果为240。
- 右移（>>）: *A >> 2* 结果为15。
- 无符号右移（>>>）: *A >>> 2* 结果为15。

#### 逻辑运算符

逻辑运算符用于根据一个或多个布尔表达式的值来执行逻辑运算，例如：

- 逻辑与（&&）: *A && B* 结果为false。
- 逻辑或（||）: *A || B* 结果为true。
- 逻辑非（!）: *!(A && B)* 结果为true。

#### 赋值运算符

赋值运算符用于将表达式的值赋给变量，例如：



- 赋值（=）: *C = A + B* 将A + B的结果赋给C。
- 加等于（+=）: *C += A* 等价于 *C = C + A*。
- 减等于（-=）: *C -= A* 等价于 *C = C - A*。
- 乘等于（*=）: *C \*= A* 等价于 *C = C \* A*。
- 除等于（/=）: *C /= A* 等价于 *C = C / A*。
- 取模等于（%=）: *C %= A* 等价于 *C = C % A*。

#### 其他运算符

Java还提供了其他类型的运算符，如条件运算符（三元运算符）、instanceof运算符等。条件运算符用于根据条件表达式的值来选择不同的值，而instanceof运算符用于检查一个对象是否为特定类的实例。

条件/三目运算符:

条件表达式?表达式1:表达式2

​	=>判断条件表达式是否成立

​		=>若成立，则执行表达式1;

​		=>若不成立，则执行表达式2;

#### 运算符优先级

当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。

下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。

| 类别     | 操作符                                     | 关联性   |
| :------- | :----------------------------------------- | :------- |
| 后缀     | () [] . (点操作符)                         | 左到右   |
| 一元     | expr++ expr--                              | 从左到右 |
| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
| 乘性     | * /％                                      | 左到右   |
| 加性     | + -                                        | 左到右   |
| 移位     | >> >>>  <<                                 | 左到右   |
| 关系     | > >= < <=                                  | 左到右   |
| 相等     | == !=                                      | 左到右   |
| 按位与   | ＆                                         | 左到右   |
| 按位异或 | ^                                          | 左到右   |
| 按位或   | \|                                         | 左到右   |
| 逻辑与   | &&                                         | 左到右   |
| 逻辑或   | \| \|                                      | 左到右   |
| 条件     | ？：                                       | 从右到左 |
| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ，                                         | 左到右   |

**移位运算符**
左移运算符<<，用于将数据的二进制位向左移动，右边使用0补充

右移运算符>>，用于将数据的二进制位向右移动，左边使用符号位补充

逻辑右移运算符>>>，用于将数据的二进制位向右移动，左边使用0补充

**位运算符**

&表示按位与运算符，就是按照二进制位进行与运算，同1为1，一0为0(1-真 0-假)

|表示按位或运算符，就是按照二进制位进行或运算，一1为1，同0为0.

~表示按位取反运算符，按照二进制位进行取反，1为0，0为1.

^表示按位异或运算符，按照二进制位进行异或运算，相同为0，不同为1.

## 六Java语言的流程

###  分支结构

#### 基本概念

在某些特殊场合中需要进行判断并作出选择时，就需要使用分支结构.

#### if分支结构

**(1)语法格式**

if(条件表达式) {

​	语句块;

}

**(2)执行流程**

判断条件表达式是否成立

​	=>若成立，则执行语句块;

​	=>若不成立，则跳过语句块;

```java
public class Test {
 
   public static void main(String args[]){
      int x = 10;
 
      if( x < 20 ){
         System.out.print("这是 if 语句");
      }
   }
}
```

#### if-else分支结构

**(1)语法格式**

​	if(条件表达式){

​		语句块1;

​	}else{

​	语句块2;

​	}
**(2)执行流程**

判断条件表达式是否成立

​	=>若成立，则执行语句块1; 

​	=>若不成立(否则)执行语句块2;

```java
public class Test {
 
   public static void main(String args[]){
      int x = 30;
 
      if( x < 20 ){
         System.out.print("这是 if 语句");
      }else{
         System.out.print("这是 else 语句");
      }
   }
}
```

#### if...else if...else语句

**（1）语法格式**

​	if(条件表达式1){

​		语句块1;

​	}

​	else if(条件表达式2){

​		语句块2;

​	}···

​	else{

​		语句块n;

​	}

**(2)执行流程**

判断条件表达式1是否成立

​	=>若成立，则执行语句块1;

​	=>若不成立，则判断条件表达式2是否成立

​		=>若成立，则执行语句块2;

​		=>若不成立，则执行语句块n;

```java
public class Test {
   public static void main(String args[]){
      int x = 30;
 
      if( x == 10 ){
         System.out.print("Value of X is 10");
      }else if( x == 20 ){
         System.out.print("Value of X is 20");
      }else if( x == 30 ){
         System.out.print("Value of X is 30");
      }else{
         System.out.print("这是 else 语句");
      }
   }
}
```

#### switch-case分支结构

**(1)语法格式**

​	switch（变量/表达式){

​		case字面值1:语句块1;break;

​		case字面值2:语句块2;break;

​		...
​		default:语句块n;

​	}

**(2)执行流程**

计算变量/表达式的数值=>判断是否匹配字面值1

​	=>若匹配，则执行语句块1=>执行break跳出当前结构

​	=>若不匹配，则判断是否匹配字面值2

​		=>若匹配，则执行语句块2=>执行break跳出当前结构

​		=>若不匹配，则执行语句块n

**注意事项：**
switch()中支持的数据类型有:byte、short、char以及int类型。

### 循环结构

#### 基本概念

在某些特殊场合中需要重复执行一段代码时，借助循环结构加以处理

#### for循环

**(1)语法格式**

for(初始化表达式;条件表达式;修改初始值表达式){

循环体;

}

**(2)执行流程**

执行初始化表达式=>判断条件表达式是否成立

=>若成立，则执行循环体=>修改初始值表达式=>判断条件表达式是否成立=>若不成立，则循环结束

```java
public class Test {
   public static void main(String[] args) {
 
      for(int x = 10; x < 20; x = x+1) {
         System.out.print("value of x : " + x );
         System.out.print("\n");
      }
   }
}
```

#### break 关键字

break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。

break 跳出最里层的循环，并且继续执行该循环下面的语句。

```java
public class Test {
   public static void main(String[] args) {
      int [] numbers = {10, 20, 30, 40, 50};
 
      for(int x : numbers ) {
         // x 等于 30 时跳出循环
         if( x == 30 ) {
            break;
         }
         System.out.print( x );
         System.out.print("\n");
      }
   }
}
```

以上实例编译运行结果如下：

```
10

20
```



#### continue 关键字

continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。

在 for 循环中，continue 语句使程序立即跳转到更新语句。

在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。

```java
public class Test {
   public static void main(String[] args) {
      int [] numbers = {10, 20, 30, 40, 50};
 
      for(int x : numbers ) {
         if( x == 30 ) {
        continue;
         }
         System.out.print( x );
         System.out.print("\n");
      }
   }
}
```

以上实例编译运行结果如下：

```
10

20

40

50
```

####  while循环

**（1）语法格式**

​	while(条件表达式){

​		循环体;

​	}
**（2）执行流程**

判断条件表达式是否成立

​	=>若成立,则执行循环体=>判断条件表达式是否成立

​	=>若不成立，则循环结束

```java
public class Test {
   public static void main(String[] args) {
      int x = 10;
      while( x < 20 ) {
         System.out.print("value of x : " + x );
         x++;
         System.out.print("\n");
      }
   }
}
```

以上实例编译运行结果如下：

```
value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19

```

#### do…while 循环

对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。

do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。

```java
public class Test {
   public static void main(String[] args){
      int x = 10;
 
      do{
         System.out.print("value of x : " + x );
         x++;
         System.out.print("\n");
      }while( x < 20 );
   }
}
```

```
value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19

```

**注意事项**

a. while循环和for循环可以完全互换;

b. while(true)和for(; ;)表示无限循环;

c. while循环主要用于明确循环条件但不明确循环次数的场合中；

​	for循环主要用于明确循环次数或范围的场合中;

## 七、Java语言的数组声明与应用

### 数组

#### 概念

数组在内存中是一块连续的空间，可以保存相同类型多个数据的容器

#### 数组的特点

数组中保存数据必须是相同的数据类型

数组是定长的(数组一旦定义不能改变长度)

#### 动态初始化

语法1: 数据类型[] 数组名 = new 数据类型[长度];

语法2: 数据类型 数组名[] = new 数据类型[长度];

```java
int[] arr = new int[3];

//存数据
arr[0] = 11;
arr[1] = 22;
arr[2] = 33;

//取数据
System.out.println("第二个元素为："+arr[1]);
System.out.println("第三个元素为："+arr[2]);

//获取数据的长度
System.out.println(arr.length);

//错误：数组下标越界
System.out.println(arr[3]);

```

####  静态初始化

语法1：数据类型[] 数组名 = {数据1,数据2,…};

语法2：数据类型 数组名[] = {数据1,数据2,…};

语法3：数据类型[] 数组名 = new 数据类型[]{数据1,数据2,…};

```java
String[] names = new String[]{"张三","李四","王五","赵六"};
// [Ljava.lang.String;@15db9742      如果直接打印数组，输出的是内存地址
// System.out.println(names);

//操作数组

//存数据
names[0] = "cxk";
names[1] = "尼古拉斯";

//取数据
System.out.println("第二个元素"+names[1]);
System.out.println("第四个元素"+names[3]);

//获取数组的长度
System.out.println("数组的长度："+names.length);

```

**数组的细节**

1. 数组中的每一个数据称之为数组元素

2. 数组中的每一个元素都对应有一个下标

3. 数组中的下标范围0~数组的长度-1

4. 数组的长度通过数组名.length获取

5. 数组的长度如果超出的边界会报错（ArrayIndexOutOfBoundsException数组下标越界异常）

   

#### 数组的默认值

> 整数型数组默认值：0
>
> 浮点型数组默认值：0.0
>
> 布尔类型数组默认值：false
> 字符型数组默认值：0 或者’ '或者 ‘\u0000’

引用类型数组默认值：null

> 数组的扩容和缩容
>
> - 步骤1：定义一个新数组，然后新数组的长度比原数组增加或者是减小
> - 步骤2：将原来数组的元素拷贝到新数组中
> - 步骤3：将原数组的变量指向新数组

 数组**扩容**示例

```java
//定义原数组
int[] arr1 = {1,3,46,22,11};

//1、定义新数组   扩容
int[] arr2 = new int[arr1.length+1];

//将原来数组的元素拷贝到新数组中
//arr2[i] = arr1[i]

//2、数组的拷贝
for (int i = 0; i < arr1.length; i++) {
    arr2[i] = arr1[i];
}

//3、将原数组的变量指向新数组
arr1 = arr2;

for (int i = 0; i < arr1.length; i++) {
    System.out.println(arr1[i]);
}

```

数组**缩容**

```java
//定义原数组
int[] arr1 = {1,3,46,22,11};

//1、定义新数组
int[] arr2 = new int[arr1.length-1];

//2、数组拷贝
for (int i = 0; i < arr2.length; i++) {
    arr2[i] = arr1[i];
}

//3、将原数组的变量指向新数组
arr1 = arr2;

for (int i = 0; i < arr2.length; i++) {
    System.out.println(arr1[i]);
}

```

#### 数组拷贝

> 数组的拷贝有三种方式：
>
> - 通过自定义循环将原数组中的元素拷贝到新数组中
> - System类提供数组拷贝方法
> - Arrays类提供数组拷贝方法

```java
//1、System类提供数组拷贝方法
int[] arr1 = {1,3,46,22,11};

//定义目标数组
int[] arr2 = new int[arr1.length + 5];

/**
* src:原数组
* srcPos：原数组的起始位置
* dest：目标数组
* destPos：目标数组的起始位置
* length：拷贝的长度
*/
System.arraycopy(arr1, 1, arr2, 3, 4);

for (int i = 0; i < arr2.length; i++) {
    System.out.print(arr2[i]+"\t");
}

```

### 二维数组

#### 二维数组的基本定义

Java中的二维数组实际上是一个数组的数组。它可以看作是一个矩阵，其中每个元素都是一维数组。二维数组的声明和初始化可以分为两种形式：固定大小的二维数组和动态大小的二维数组。

1、声明和初始化二维数组

创建二维数组的基本语法如下：

```java
// 声明并初始化一个二维数组
int[][] matrix = new int[3][4]; // 3行4列的二维数组
```

这行代码声明了一个3行4列的二维数组，所有元素的默认值为0。可以通过索引来访问和修改数组中的元素：

```java
matrix[0][0] = 10;  // 设置第一行第一列的元素为10
matrix[2][3] = 25;  // 设置第三行第四列的元素为25
```

2、使用静态初始化二维数组

如果我们在声明时就能确定数组的元素值，可以使用静态初始化：

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

这种方式不仅声明了二维数组，还为每个元素赋了初始值，数组的行数和列数由初始化数据自动决定。

#### 二维数组的遍历

遍历二维数组是最常见的操作之一，通常可以通过两层循环来实现。外层循环遍历行，内层循环遍历列。

 1、使用`for`循环遍历二维数组

```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println();  // 每输出一行后换行
}
```

```
结果：1 2 3 4 5 6 7 8 9
```

2、使用增强型`for`循环遍历二维数组

如果不关心行和列的索引，可以使用增强型`for`循环来遍历二维数组：

```java
for (int[] row : matrix) {
    for (int value : row) {
        System.out.print(value + " ");
    }
    System.out.println();
}
```

这种方式使代码更加简洁，尤其适合那些不需要索引的场景。

#### 二维数组的动态大小

二维数组可以不等行列，即每一行的列数可以不同，这在某些特定情况下非常有用。我们可以通过创建一个数组的数组来实现动态大小的二维数组。

 1、动态创建不规则二维数组

```java
int[][] dynamicMatrix = new int[3][]; // 3行，列数不固定
dynamicMatrix[0] = new int[2];  // 第一行有2列
dynamicMatrix[1] = new int[3];  // 第二行有3列
dynamicMatrix[2] = new int[4];  // 第三行有4列
dynamicMatrix[0][0] = 1;
dynamicMatrix[1][2] = 5;
dynamicMatrix[2][3] = 9;
for (int i = 0; i < dynamicMatrix.length; i++) {
    for (int j = 0; j < dynamicMatrix[i].length; j++) {
        System.out.print(dynamicMatrix[i][j] + " ");
    }
    System.out.println();
}
```

```
输出结果：
1 0 
0 0 5 
0 0 0 9
```

在这个例子中，我们创建了一个3行不规则的二维数组。每行的列数可以根据需求动态调整。

#### 二维数组的常见应用

二维数组的应用非常广泛，下面是几个常见的使用场景：

1、矩阵运算

例如，进行矩阵的加法、乘法等运算时，二维数组是不可或缺的工具。

```java
public class MatrixAddition {
    public static void main(String[] args) {
        int[][] matrixA = {
            {1, 2},
            {3, 4}
        };
        int[][] matrixB = {
            {5, 6},
            {7, 8}
        };
        
        int[][] result = new int[2][2];
        
        // 矩阵加法
        for (int i = 0; i < matrixA.length; i++) {
            for (int j = 0; j < matrixA[i].length; j++) {
                result[i][j] = matrixA[i][j] + matrixB[i][j];
            }
        }
        
        // 输出结果矩阵
        for (int i = 0; i < result.length; i++) {
            for (int j = 0; j < result[i].length; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

```
输出结果：
6 8 
10 12
```

2、表格数据存储

二维数组可以用来存储和处理表格数据，像Excel表格、成绩单等。例如，存储一个班级的学生成绩：

```java
public class StudentScores {
    public static void main(String[] args) {
        String[][] students = {
            {"张三", "90", "85", "88"},
            {"李四", "78", "83", "80"},
            {"王五", "92", "91", "95"}
        };
        
        // 输出成绩表
        System.out.println("学生成绩表:");
        System.out.println("姓名\t语文\t数学\t英语");
        for (int i = 0; i < students.length; i++) {
            for (int j = 0; j < students[i].length; j++) {
                System.out.print(students[i][j] + "\t");
            }
            System.out.println();
        }
    }
}
```

```
输出结果：
学生成绩表:
姓名    语文    数学    英语
张三    90      85      88
李四    78      83      80
王五    92      91      95
```

**二维数组的注意事项**

> 1. **索引从0开始**：二维数组的行列索引均从0开始，访问元素时要小心。
> 2. **不规则数组**：如果二维数组的每一行列数不相同，访问时一定要特别注意数组的长度，以避免`ArrayIndexOutOfBoundsException`错误。
> 3. **内存占用**：二维数组在内存中的分配是连续的，如果是动态数组，可能会占用不规则的内存区域。

### Java 面向对象数组的增删改查

ava 是一种面向对象的编程语言，面向对象的编程思想使得我们能更好地组织和管理代码。在这篇文章中，我们将一起学习如何实现一个简单的 Java 类，并使用数组来进行增、删、改、查（CRUD）操作。

### 流程步骤

1.定义一个 Java 类
2.创建一个对象数组
3.实现增（Add）方法
4.实现删（Delete）方法
5.实现改（Update）方法
6.实现查（Retrieve）方法

接下来，我们将对每个步骤进行详细解释，并提供相应的代码示例。

#### 定义 Java 类

首先，我们需要创建一个类，这个类将作为我们对象的模板。例如，我们可以创建一个 Student 类，以表示学生的信息。

```java
// 定义一个 Student 类
public class Student {
    private String name;
    private int age;

    // 构造函数
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 获取名称
    public String getName() {
        return name;
    }

    // 获取年龄
    public int getAge() {
        return age;
    }

    // 设置名称
    public void setName(String name) {
        this.name = name;
    }

    // 设置年龄
    public void setAge(int age) {
        this.age = age;
    }
}
```

说明: Student 类包含两个属性：name 和 age，以及相应的构造函数和 getter/setter 方法。

#### 创建对象数组

接下来，我们将在主类中创建一个 Student 类型的数组，用于存储多个学生对象。

```java
public class StudentManager {
    private Student[] students;
    private int count;

    // 构造函数，初始化学生数组
    public StudentManager(int size) {
        students = new Student[size];
        count = 0;
    }
}
```

说明: StudentManager 类中创建了一个 students 数组和一个计数器 count，用于跟踪当前学生数量。

#### 实现增（Add）方法

我们来实现一个添加学生的方法。

```java
public void addStudent(String name, int age) {
    if (count < students.length) {
        students[count] = new Student(name, age); // 创建新的 Student 对象
        count++; // 增加计数
    } else {
        System.out.println("数组已满，无法添加更多学生");
    }
}
```

说明: addStudent 方法检查数组是否已满，如果未满，则创建新的 Student 对象并添加到数组中。

#### 实现删（Delete）方法

接着，实现一个删除学生的方法。

  ```java
public void deleteStudent(int index) {
    if (index >= 0 && index < count) {
        for (int i = index; i < count - 1; i++) {
            students[i] = students[i + 1]; // 移动后面的学生
        }
        students[count - 1] = null; // 清除最后一个元素
        count--; // 减少计数
    } else {
        System.out.println("索引超出范围");
    }
}
  ```

说明: deleteStudent 方法根据索引删除学生，并在数组中移位。

#### 实现改（Update）方法

我们还需要一个更新学生信息的方法。

```
public void updateStudent(int index, String name, int age) {
    if (index >= 0 && index < count) {
        students[index].setName(name); // 更新名称
        students[index].setAge(age); // 更新年龄
    } else {
        System.out.println("索引超出范围");
    }
}
```

说明: updateStudent 方法用新的名称和年龄更新指定索引的学生。

#### 实现查（Retrieve）方法

最后，实现一个显示学生信息的方法。

```java
public void displayStudents() {
    for (int i = 0; i < count; i++) {
        System.out.println("学生名称: " + students[i].getName() + ", 年龄: " + students[i].getAge());
    }
}
```

说明: displayStudents 方法循环遍历学生数组，并输出每个学生的名称和年龄。

## 八、面向对象

### 对象和类的概念

对象是客观存在的实体，在Java语言体现为内存空间的一块区域。

类就是分类的概念，是对具有相同特征和行为的多个对象共性的抽象描述，在Java语言中包含描述特征的成员变量和描述行为的成员方法，是创建对象的板。

#### Java 对象和类

Java 作为一种面向对象的编程语言，支持以下基本概念：

**类（Class）**：

- 定义对象的蓝图，包括属性和方法。

**对象（Object）**：

- 类的实例，具有状态和行为。

**继承（Inheritance）**：

- 一个类可以继承另一个类的属性和方法。

**封装（Encapsulation）**：

- 将对象的状态（字段）私有化，通过公共方法访问。

**多态（Polymorphism）**：

- 对象可以表现为多种形态，主要通过方法重载和方法重写实现。

**抽象（Abstraction）**：

- 使用抽象类和接口来定义必须实现的方法，不提供具体实现。

**接口（Interface）**：

- 定义类必须实现的方法，支持多重继承。

**方法（Method）**：

- 定义类的行为，包含在类中的函数。

**方法重载（Method Overloading）**：

- 同一个类中可以有多个同名的方法，但参数不同。

#### Java中的对象



现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。

拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。

对比现实对象和软件对象，它们之间十分相似。

软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。

在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。

#### Java 中的类

类可以看成是创建 Java 对象的模板。

![image-20250702110053231](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250702110053231.png)

通过上图创建一个简单的类来理解下 Java 中类的定义：

```java
public class Dog {
    String breed;
    int size;
    String colour;
    int age;
 
    void eat() {
    }
 
    void run() {
    }
 
    void sleep(){
    }
 
    void name(){
    }
}
```

一个类可以包含以下类型变量：

- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。

### 类、对象以及引用

#### 类的定义

##### 类定义的语法格式

​	class 类名{

​		类体;

​	}

如:

```java
class Person{
   
}
```

**注意:**

当类名由多个单词组成时，要求每个单词的首字母都要大写;

##### 成员变量定义的语法格式

class 类名{

数据类型  成员变量名=初始值;

其中=初始值通常省略，但分号不能省略
如:

```java
class Person{
	String name;
	int age;
}
```

**注意:**
当成员变量名由多个单词组成时，要求从第二个单词起每个单词首字母大写;

#### 对象的创建

**(1)语法格式**

new 类名();
如:

```java
new Person();
```

创建Person类型的对象，由于该对象没有名字因此叫做"匿名对象
**(2)注意事项**

a.当一个类定义完毕后，使用new关键字创建/构造对象的过程叫做类的实例化;

b.创建对象的本质就是在内存中的堆区申请存储空间，来存放该对象独有的特征信息

#### 引用

**(1)基本概念**

除8种基本类型之外，用类名(接口、数组)声明的变量称为引量，简称“引用”

在Java语言中使用引用数据类型声明的变量叫做引用型变量，简称为"引用”。

引用变量主要用于记录对象在堆区中的内存地址信息，便于下次访问。
**(2)语法格式**

类名 引用变量名；
如:

```java
Person p;
```

表示声明Person类型的引用变量p，本质上在栈区申请存储空间

```java
Person p = new Person();
```

表示声明引用变量p来记录Person类型对象的地址信息

###  成员方法

#### 语法格式

​	class 类名{
​		返回值类型 成员方法名(形参列表){

​			成员方法体;

​		}

​	}

如：

```java
class Person{
    void show(){
        System.out.println("内容！");
    }
}
```

**注意:**
当成员变量名由多个单词组成时，通常要求从第二个单词起每个单词首字母大写。

#### 格式的详解

**返回值类型**

返回值：方法调用结束后可以返回一个数据，称之为返回值。

返回值主要指从方法体内向方法体外返回的数据内容。

返回值类型主要指返回值的数据类型，可以是基本数据类型，也可以是引用数据类型
如 :

​	当返回的数据内容是66时，则返回值类型写int即可;

​	当返回的数据内容是3.14时，则返回值类型写double即可;

​	当返回的数据内容是"hello"时，则返回值类型写String即可:

在方法体中使用return关键字来返回数据内容并结束当前方法。

如：

​	当返回的数据内容是66时，则方法体中写: return66;

​	当返回的数据内容是num时，则方法体中写: return num;

若该方法不需要返回任何数据内容，则返回值类型写void即可。

**形参列表**

方法的参数是指:在调用时传递给方法，需要被方法处理的据。

形式参数主要用于将方法体外的数据传入到方法体的内部，格式:数据类型形参名

形参列表主要指多个形式参数组成的整体，格式如下:

​	数据类型 形参名1,数据类型 形参名2，...

如：

​	当传入的数据内容是66时，则形参列表写为: inti即可;

​	当传入的数据内容是3.14时，则形参列表写为: double d即可；

​	当传入的数据内容是”hello"时，则形参列表写为: String s即可;

​	当传入的数据内容是66和"hello"时，则形参列表写为:int i，String s即可；

若该方法不需要传入任何数据内容时，则形参列表位置啥也不写即可;

**成员方法体**

成员方法体成员方法体主要编写描述该方法功能的语句。

如：

当该方法的功能就是打印时，则方法体中写 System.out.println("...”);即可

当该方法的功能就是返回66时，则方法体中写return 66;即可

#### 方法的调用

**(1)语法格式**

​	引用变量名.成员方法名(实参列表)；

如:
p.show()；	-表示使用引用变量p调用show方法
**(2)注意事项**

a.实际参数列表主要用于对形式参数列表进行初始化操作，因此参数的个数、类型顺序等都必须与形参列表保持一致;

b.实参可以传递直接量、变量、表达式以及方法的调用等;

### 构造方法及方法重载

#### 构造方法

（1）语法格式

​	class 类名{

​		类名（形参列表）{

​			构造方法体；

​		}

​	}

如：

```java
class Person{
    Person(){
        
    }
}
```

(2)注意事项
	a.构造方法的名称与类名完全相同，没有返回值类型连void都不许有。
	b.当使用new关键字构造对象时会自动调用构造方法进行成员变量的初始化工作。
(3)默认构造方法

​	a.当一个类中没有自定义任何形式的构造方法时，编译器会自动添加一个无参的空构造方法，叫做默认/缺省构造方法，如: Person(){}

#### 方法的重载（Overload）

(1)基本概念
	在Java语言中若方法的名称相同但参数列表不同，这样的方法之间构成重载关系
(2)体现形式

​	方法重载的主要形式有:参数的个数不同、参数的类型不同、参数的顺序不同，与形参变量名和返回值类型无关，但建议返回值类型最好相同。

​	判断方法是否重载的核心:调用能否区分。

(3)实际意义
	对于调用者来说只需要记住一个方法名就可以调用各种不同的版本实现不同的效果

如：

```java
char c = 'a';
System.out.println(c);
int i=10;
System.out.println(i);
double d=3.14;
System.out.println(d);
...
```

### this关键字

#### 基本概念

在构造方法中this关键字代表当前正在构造的对象。
在成员方法中this咲键字代表当前正在调用的对象。

**原理分析**

​	当成员方法中访问成员变量时默认会加上this.(相当于汉语中"我的")，当不同的引用调用同一个成员方法时会导致成员方法中的this不同，那么this.访问的结果随之不同。

**作用**

​	所有的成员变量不能重名，在同一区域的局部变量不能重名，但成员变量和局部变量可以重名。在局部变量的作用区域之外，变量名代表成员变量，在局部变量的作用区域之内，代表局部变量，如果想使用成员变量，需要this.的方式访问。

在方法中可以通过this关键字表示“调用该方法的那个对象”

```java
public void down(inty) {

	this.y+=y;

}
```

#### 使用方式

​	**1、引用当前对象的属性或方法：**当构造方法的参数名与类属性名相同时，使用 this 来区分类属性和参数。例如：

```java
public Person(String name, int age) {
    this.name = name; // this.name 表示类的属性
    this.age = age;
}
```

​	**2、调用另一个构造方法：**可以使用 this() 调用当前类的其他构造方法，常用于避免重复代码，但必须放在构造方法的第一行。

```java
public Person(String name) {
    this(name, 0); // 调用另一个双参数的构造方法
}

public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
```



### 方法的传参和递归调用

#### 方法的传参过程

**main方法是程序的入口，为main方法中的局部变量开辟内存空间并初始化；**

1. 调用max方法时为max方法的形参变量开辟内存空间;
2. 使用实参变量给形参变量进行赋值操作，执行max方法的方法体;
3. 当max方法结束后释放形参变量的内存空间；
4. main方法中的res得到max方法的返回值然后继续向下执行；
5. 当main方法结束后释放局部变量的内存空间;

**传参基本概念**

Java中的方法可以传递参数，参数的传递方法就是值传递。

参数有形参和实参，定义方法时写的参数叫形参，真正调用方法时，传递的参数叫实参。调用方法时，会把实参传递给形参，方法内部其实是在使用形参。

所谓值传递就是当参数是基本类型时，传递参数的值，比如传递i=10，真实传参时，把10赋值给了形参。当参数是对象时，传递的是对象的值，也就是对象的首地址。就是把对象的地址赋值给形参。

#### 递归调用

**基本概念**

​	方法自包调用自己就叫递归。

​	递归有可能会大幅简化代码的编写。

​	递归要考虑性能问题，有些时候可以使用循环而不是递归。

**递归的使用原则**
1 必须有退出条件。
2 必须使问题变简单，而不是复杂化。

如：

```java
void show(){
    show();
}
```

**注意：**

a.必须找到递归的规律和退出条件;

b.使用递归使得问题简单化而不是复杂化；

c.若递归影响到程序的执行性能则使用递推取代之；

## 九、面向对象的封装特性和static关键字

### 封装

#### 基本概念

​	通常情况下测试类可以对封装类中的成员变量进行赋值，若赋值的数据合法但不合理时，无论时编译阶段还是运行阶段都不会报错或者给出提示，此时与现实生活不符。为了避免上述错误的发生，就需要对成员变量进行密封包装处理，该机制就叫做封装,换句话说，封装就是一种保证成员变量值合理性的机制。

#### 实现Java封装的步骤

1. 修改属性的可见性来限制对属性的访问（一般限制为private），例如：

```java
public class Person {
    private String name;
    private int age;
}
```

​	这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。

2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：

3. ```java
   public class Person{
       private String name;
       private int age;
   ​
       public int getAge(){
         return age;
       }
   ​
       public String getName(){
         return name;
       }
   ​
       public void setAge(int age){
         this.age = age;
       }
   ​
       public void setName(String name){
         this.name = name;
       }
   }
   ```

   ​	采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。

### static关键字

#### 概念

​	通常情况下，属性/方法都是隶属于对象层级，就是每个对象都有自己独有的属性空间，有些属性需要属于整个类，就是所有对象要共享。static就是把对象级提升到类级。

​	static的属性/代码块/方法都是隶属于类，在类加载时就准备完成了，而不需要创建对象(new)。

类加载只做一次，包括：
1 类名.的时候会类加载。
2 new对象时会类加载。
3 程序员可以用程序加载，比如: Class.forName()。
静态的成员(属性和方法)可以用对象.调用，但一般推荐用类名.调用。

#### 使用方式

(1)在非静态的成员方法中既能访问非静态的成员也能访问静态的成员；

(成员:成员变量+成员方法，静态成员被所有对象共享)

(2)在静态的成员方法中只能访问静态的成员不能访问非静态的成员;

(成员:成员变量+成员方法，调用静态方法时可能还没有创建对象）

(3)只有隶属于类层级被所有对象共享的内容才可以使用static修饰;

(不能滥用static关键字)

#### 单例设计模式

(1)基本概念

​	在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。
(2)实现流程

a.私有化构造方法，使用private关键字修饰；

b.声明本类类型的引用指向本类类型的对象，使用private static共同修饰；

c.提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰；

(3)实现方式
单例设计模式的实现方式有两种:饿汉式和懒汉式，在以后的开发中推荐饿汉式。

#### 代码块和静态代码块

代码块-- java允许直接用{}写代码，叫代码块。

​	写在类体中的代码块叫构造块，每创建一个对象，构造块都会被执行一次 。

​	前面加static的构造块叫静态代码块，类加载时执行一次。

### 继承

#### 基本概念

​	当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式叫做继承。

​	使用继承可以提高代码的复用性和扩展性以及可维护性。

​	在Java语言中使用extends(扩展)关键字来表达继承关系。

如：

public class Student extends Person{}

表示Student类继承自Person类

其中Person类叫做基类、父类、超类

其中Student类叫做派生类、子类、孩子类

#### 构造方法

​	子类的构造方法中必须通过super关键字调用父类的构造方法，这样可以妥善的初始化继承自父类的成员变量。

​	如果子类的构造方法中没有调用父类的构造方法，也没有使用this()调用本类构造，Java编译器会自动的加入对父类无参构造方法的调用(如果该父类没有无参的构造方法，会有编译错误)。

​	this()和super()必须出现在构造的第一行，因此不可能同时出现。

```java
Circle(){}
    Cirle(intx,inty,int r){
        super(x,y);
        this.r=r;
    }

```

#### 注意事项

​	（1）子类可以继承父类的成员变量和成员方法，其中私有成员变量可以继承但不可以直接使用。

​	（2）无论使用何种方式构造子类对象时，都会自动调用父类中的无参构造方法来初始化从父类中继承下来的成员变量，相当于在子类构造方法第一行增加代码:super()的效果。

​	（3）使用继承必须满足子类is  a父类的逻辑关系，”也就是不能滥用继承。

​	（4）Java语言中只支持单继承不支持多继承，也就是一个子类只能有一个父类，但一个父类可以有多个子类。

#### 方法的重写(override)

（1）基本概念

若从父类中继承下来的方法不满足子类的需求时，就需要在子类中重新写一个与父类中一样的方法来覆盖从父类中继承的版本，这种方式就叫做重写。

（2）重写的原则
a.要求方法名相同、参数列表相同、返回值类型相同。

b.要求方法的访问权限不能变小，可以相同或者变大。

c.要求不能抛出更大的异常(异常机制)。

d. static的方法重写以后还是static的。

## 十、访问控制和final关键字

### 访问控制

#### 访问控制修饰符

- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**

- **public** : 对所有类可见。使用对象：类、接口、变量、方法

- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。

  我们可以通过以下表来说明访问权限：

- | 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
  | :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
  | `public`    | Y      | Y        | Y              | Y                                                            | Y      |
  | `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | N      |
  | `default`   | Y      | Y        | Y              | N                                                            | N      |
  | `private`   | Y      | N        | N              | N                                                            | N      |

#### 默认访问修饰符-不使用任何关键字

如果在类、变量、方法或构造函数的定义中没有指定任何访问修饰符，那么它们就默认具有默认访问修饰符。

默认访问修饰符的访问级别是包级别（package-level），即只能被同一包中的其他类访问。

#### 私有访问修饰符-private

私有访问修饰符是最严格的访问级别，所以被声明为 **private** 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 **private**。

声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。

Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。

#### 公有访问修饰符-public

被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。

如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。

#### 受保护的访问修饰符-protected

protected 需要从以下两个点来分析说明：

- **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
- **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

protected 可以修饰数据成员，构造方法，方法成员，**不能修饰类（内部类除外）**。

### 非访问修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

static 修饰符，用来修饰类方法和类变量。

final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

abstract 修饰符，用来创建抽象类和抽象方法。

synchronized 和 volatile 修饰符，主要用于线程的编程。

### static 修饰符

#### 静态变量

static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。

#### 静态方法

static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

对类变量和方法的访问可以直接使用 **classname.variablename** 和 **classname.methodname** 的方式访问。

### final关键字

#### 基本概念

​	final本意为"最终的，不可更改的"，该关键字可以修饰类、成员方法、成员变量等。

#### 使用方式

final关键字修饰类表示该类不能被继承。

​	为了防止滥用继承带来的危害

​	如:java.lang.String类等

final关键字修饰成员方法表示该方法不能被重写但可以被继承。

​	为了防止不经意间造成的方法重写

​	如：java.text.DateFormat类中的format方法等；

final关键字修饰成员变量表示该成员变量必须初始化而且不能更改。

​	为了防止不经意间造成数值的更改。

​	如:java.lang.Thread类中的MAX_PRIORITY等

## 十一、面向对象的多态特性及抽象类和接口

### 多态

#### 基本概念

多态主要指同一种事物表现出来的多种形态

#### 语法格式

父类类型 引用变量名 = new 子类类型（）；

如：

```java
Person pw = new Woker();
pw.show();
```

解析:
编译阶段调用Person类中show方法，在运行阶段调用Worker类中重写以后的show方法。

#### 多态的优点

1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性

#### 多态的效果

- 当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有的方法；
- 当父类的引用指向子类的对象时,父类的引用不可以直接调用子类独有的方法;
- 对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类重写以后的版本;
  对于父子类都有的静态方法来说，编译和运行阶段调用父类版本，隶属于类层级，因此与指向的对象无关;

#### 应用数据类型之间的切换

（1）引用数据类型之间的转换分为:自动类型转换 和 强制类型转换。

​	其中自动类型转换主要指从小范围到大范围之间的转换，也就是子类到父类的转换。

​	其中强制类型转换主要指从大范围到小范围之间的转换，一也就是父类到子类的转换。

（2）引用数据类型之间的转换必须发生在父子类之间，否则编译报错

（3）若转换到的目标类型是子类类型但不是该引用真正指向的子类类型，则编译通过，运行阶段发生类型转换异常。

（4）为了避免上述错误的发生，可以使用instanceof进行判断，具体格式如下:

​	if(引用变量名instanceof 数据类型) //判断引用变量指向的对象是否为后面类型

#### 多态的意义

​	多态的实际意义在于可以屏蔽不同子类的差异性实现通用的编程，但可以调用不同的方法带来不同的结果。

### 抽象类

#### 抽象方法的概念

​	抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰。

#### 语法格式

​	访问控制符 abstract 返回值类型 方法名称(形参列表);
如:

```java
public abstract void cry();
```

#### 抽象类的概念

​	抽象类就是指不能具体实例化的类，也就是不能创建对象并使用abstract关键字修饰

**注意事项**

1. 抽象类中可以有成员变量、构造方法以及成员方法;
2. 抽象类中可以有抽象方法也可以没有抽象方法;
3. 拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并且使用abstract关键字修饰的类才算真正意义上的抽象类。

#### 实际意义

抽象类的意义不在于自身创建对象而在于被继承，当一个类继承抽象类后必须重写抽象类中的抽象方法，否则该类也变成抽象类。也就是说抽象类对子类具有强制性和规范性，因此叫做模板设计模式。

### 接口

#### 基本概念

​	接口就是一种比抽象类还抽象的类，体现为所有成员方法都是抽象方法。

​	定义类的关键字是class，而定义接口的关键字是interface。

​	继承类的关键字是extends，而实现接口的关键字是implements。

#### 抽象类和接口之间的区别

1. 定义抽象类的关键字是abstract class，而定义接口的关键字是interface。
2. 继承抽象类的关键字是extends，而实现接口的关键字是implements。
3. 继承抽象类支持单继承，而实现接口可以多实现。
4. 抽象类中可以有构造方法，而接口中不可以有构造方法。
5. 抽象类中可以有成员变量，而接口中只可以有常量。
6. 抽象类中可以有成员方法，而接口中只可以有抽象方法。
7. 抽象类中增加方法可以不影响子类，而接口中增加方法通常都影响子类。
8. 从jdk1.8开始允许接口中出现非抽象方法，但需要使用default关键字修饰。

#### 多态的使用场合

a.通过方法的参数传递形成多态：

```java
public static void draw(Shape s){}

TestShape.draw(new Rect(1,2,3,4));
```

b.在方法体中直接使用多态的语法格式：

```java
TestAbstract ta=new SubTestAbstract()；

ta.show()；
```

### 内部类

#### 基本概念

​	当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类，而这个内部类所在的类叫做外部类。

​	类中的内容:成员变量、成员方法、构造方法、静态成员、构造块和静态代码块、内部类。

#### 语法格式

​	class 外部类名{

​		class 内部类名{

​			内部类的类体；

​		}

​	}

如：

```java
class A{
	class B{
	}
}
```

#### 实际作用

​	当一个类存在的价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为所服务类中的内部类，这样可以隐藏该类的实现细节并且可以方便的访问外部类的私有成员而不再需要提供公有的get和set方法。

#### 基本分类

普通内部类——直接将一个类的定义放在另外一个类的类体中。

静态内部类——使用static关键字修饰的内部类，隶属于类层级。

局部内部类——直接将一个类的定义放在方法体的内部时。

​         Java的各种数据类型对象库的处理应用

### Ob ject类

#### Java的包结构

- java.lang包 是Java最核心的包，JVM一启动自动加载这个包的所有类和接口无需import。常见的类:System/String/Object/Class/...

​	java.util包 是Java的工具包，包括很多工具类和集合。

​	java.io 包 是输入输出的包，包括读写各种设备。

​	java.net包 是网络编程的包，包括各种网络编程。

​	java.sql包 是操作数据库的所有类和接口。

- Java程序员在编程时，可以使用大量的类库，因此，Java编程需要记的很多，对编程能力的本身要求不是特别的高。

### 0bject类

#### 基本概念

java.lang.0bject类是所有类层次结构的根类，任何类都是该类的直接或间接子类

#### 常用的方法

**0bject()：**使用无参方式构造对象。

**boolean equals(0b ject ob j)：**用于判断调用对象是否与参数对象相等。

该方法默认比较两个对象的地址，与==运算符结果相同。

为了使得该方法比较两个对象的内容，则需要重写该方法。

若该方法重写后，则应该重写hashCode方法来维护hashCode方法的常规协定

**int hashCode()：**用于获取调用对象的哈希码值(内存地址的编号)。

若调用equals方法的结果相等，则各自调用hashCode方法的结果相同。

若调用equals方法的结果不相等，则各自调用hashCode方法的结果不相同。

为了维护上述的常规协定与equals方法结果保持一致，就需要重写该方法。

为了维护上述的常规协定与equals方法结果保持一致，就需要重写该方法。

**String toString()：**用于获取对象的字符串形式。

该方法默认返回的字符串为:包名.类名@哈希码值的十六进制形式。

为了返回更有意义的数据内容则需要重写该方法。

当字符串内容与引用进行连接时，自动调用toString方法。

当使用print或println方法打印引用时，会自动调用toString方法。

### 包装类和数学处理类

如：

Person p=new Person();声明Person类型的引用指向Person类型的对象

int num =10；声明一个int类型的变量num初始值为10

#### 包装类的概念

​	由于Java语言是一门纯面向对象编程语言，而8种基本数据类型声明的变量并不是对象为了满足Java语言的特性就需要对这些变量进行对象化处理，而实现该功能的相关类就叫做包装类。

#### 包装类的分类

int =>java.lang.Integer类

char =>java.lang.Character类

其它类型对应的包装类就是将首字母变成大写

### Integer类

#### 基本概念

java. lang.Integer类是int类型的包装类，里面包含了一个int类型的成员变量。该类由final关键字修饰表示不能被继承。

#### 常用的方法

Integer(int value)-根据参数指定的整数构造对象。

Integer(String s)-根据参数指定的字符串构造对象。

该类重写了equals（）、hashCode（）、toString（）方法。

int intValue()-用于获取调用对象中的整数数据并返回。

static Integer value0f(int i)-根据参数指定的整数返回对应的Integer对象。

static int parseInt(String s)-用于将String类型转换为int类型并返回。

### BigDecimal类

#### 基本概念

​	由于float类型和double类型的运算可能会有误差，为了实现精确运算则需要借助java.math.BigDecimal类型加以描述。

#### 常用的方法

​	BigDecimal(String val)-根据参数指定的字符串构造对象

​	BigDecimal add(BigDecimal augend)-用于计算调用对象和参数对象的和并返回

​	BigDecimal subtract(BigDecimal subtrahend)-用于计算调用对象和参数对象的差并返回。

​	BigDecimal divide(BigDecimal divisor)-用于计算调用对象和参数对象的商并返回 。

### String类

#### 基本概念

​	java.lang.String类用于描述字符串，Java应用程序中所有字符串字面值都可以作为String类型的对象加以描述，如:"abc"等。

​	该类描述的字符串内容是个常量，一旦创建完毕后则不能更改，因此可以被共享。

如：

```java
String strl="abc";
strl ="123";
改变str1的指向而不是指向的内容
```

#### 常量池

​	由于String类型描述的字符串内容是个常量不可改变，因此Java虚拟机提供了一个常当Java程序中出现字符串内容时就放入常量池中，若后续出现重复的字符串内容贝量池，直接使用池中已有的对象而不需再次创建，从而提高了性能。

#### String类的构造方法

String()：使用无参方式构造对象得到空字符序列

String(byte[] bytes, int offset,int length):使用bytes数组中下标从offset位置开始的length个字节来构造对象

String(byte[l bytes):使用bytes数组中的所有内容构造对象

String(char[]value,int offset,int count):

使用value数组中下标从offset位置开始的count个字符来构造对象

String(char[]value):使用value数组中的所有内容构造对象

String(Stringoriginal):根据参数指定的字符串内容来构造对象，新创建对象为参数对象的副本                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

## 十二、Java字符串和日期处理

### String类的常用方法

**String定义有charAt方法:**

| char charAt(intindex) | 方法charAt用于返回字符串指定位置的字符。参数index表示指定的位置 |
| --------------------- | ------------------------------------------------------------ |
| int length()          | 返回字符串字符序列的长度                                     |

**String类的基本方法如下:**

boolean equals(0bjectanObject)：用于比较字符串内容是否相等并返

回文：

```java
String str=“海自来水来自海上”;
for(int i=0;i<str.length()/2;i++){
    if(str.charAt(i)!=str.charAt(str.length()-1-i)){
        System.out.println("不是回文");
        return;
    }
}
System.out.println("是回文");
```

**String提供几个重载的indexOf方法:**

| int indexOf(Stringstr)              | 在字符串中检索str，返回其第一出现的位置，如果找不到则返回-1 |
| ----------------------------------- | ----------------------------------------------------------- |
| intindexOf(Stringstr,int fromIndex) | 类似indexOf(String)，但是是从字符串的fromIndex位置开始检索  |

**substring方法：**

用于返回一个字符串的子字符串。

substring常用重载方法定义如下：

| String substring(<br/>int beginindex,int endindex) | 返回字符串中从下标beginIndex(包括)开始到endIndex(不包括)结束的子字符串 |
| -------------------------------------------------- | ------------------------------------------------------------ |
| String substring(int beginlndex)                   | 返回字符串中从下标beginIndex(包括)开始到字符串结尾的子字符串 |



### StringBuilder类和StringBuffer类

如：

```java
String str1 = "ab";
String str2 = "abc";
String str3 = "abcd";
... ...
```

#### 基本概念

​	由于String类型描述的字符串内容是个常量不可更改，当程序中出现大量类似的字符串时需要单独存放从而浪费内存空间，若希望使用一块内存空间进行存储并且可以修改字符串内容，则应该使用StringBuilder类和StringBuffer类。

​	其中StringBuffer类从jdk1.0开始存在，该类支持线程安全，因此访问的效率比较低。

​	其中StringBuilder类从jdk1.5开始存在，该类不支持线程安全，访问的效率比较高。

#### StringBuilder类的常用方法

| StringBuilder类的常用方法                           | 功能描述   |
| --------------------------------------------------- | ---------- |
| StringBuilder append(String str)                    | 追加字符串 |
| StringBuilder insert(int offset, String str)        | 插入字符串 |
| StringBuilder delete(intstart, int end)             | 删除字符串 |
| StringBuilder replace(intstart, intend, Stringstr） | 代替字符串 |
| StringBuilder reverse()                             | 字符串反转 |

#### 返回值的意义

​	StringBuilder的很多方法的返回值均为StringBuilder类型。这些方法的返回语句均为:return this。

​	可见，这些方法在对StringBuilder所封装的字符序列进行改变后又返回了该对象的引用。基于这样的设计的目的在于可以按照如下简洁的方式书写代码:

```java
sb.append("ibm").append("java").insert(3,"oracle").replace(9,13,"JAVA");
System.out.println(sb.toString());
```



### 日期相关的类

#### Date类

#### 基本概念

java.util.Date类用于描述特定的瞬间，可以精确到毫秒。

#### SimpleDateFormat类的概述

java.text.SimpleDateFormat类用于实现Date对象和字符串表示的日期信息间的转换。

其构造方法如下:

```java
SimpleDateFormat(Stringpattern)
SimpleDateFormatsdf
    = new SimpleDateFormat("yyyy年MM月dd日");
Date date= new Date();
String dateStr=sdf.format(date);
System.out.println(dateStr);
```

#### Calendar类

#### 基本概念

​	java.util.Calendar类用于取代Date类来描述年月日时分秒的特定瞬间。 

​	Calendar是抽象类，其具体子类针对不同国家的日历系统，其中应用最广泛的是GregorianCalendar(格里高利历)，对应世界上绝大多数国家/地区使用的标准日历系统。

Calendar c=Calendar.getInstance();

## 十三、包装类、集合、数据结构

### 集合（容器）框架

#### 集合的由来

当需要在程序中记录单个数据内容时，则声明一个变量即可;

当需要在程序中记录多个类型相同的数据内容时，!则声明一个一维数组即可；

当需要在程序中记录多个类型不同的数据内容时，则构造一个对象即可;

当需要在程序中记录多个类型相同的对象时，则声明一个对象数组即可;

当需要在程序中记录多个类型不同的对象时，则声明一个集合即可;

#### 集合框架结构

​	在Java语言中集合框架的顶层是:java.util.Collection集合和 java.util.Map集合

​	其中Collection集合中操作元素的基本单位是:单个元素。

​	其中Map集合中操作元素的基本单位是:单对元素。

​	在以后的开发中很少直接使用Collection集合，而是使用该集合的子集合:List集合、Queue集合、Set集合等。

### Collection集合

#### 基本概念

​	java.util.Collection集合是集合框架的根接口，其它接口是该接口的子接口。

Collection框架的概述

​	在实际开发中，需要将使用的对象存储于特定数据结构的容器中。
​	Java提供了容器一集合框架，集合框架中包含一系列不同数据结构的实现类。

![image-20250705151525592](C:\Users\29443\AppData\Roaming\Typora\typora-user-images\image-20250705151525592.png)

#### Collction集合的常用方法

| boolean add(E e);           | 向集合中添加对象     |
| --------------------------- | -------------------- |
| boolean contains(Object o); | 判断是否包含指定对象 |
| boolean emove(Object o);    | 从集合中删除对象     |
| void clear();               | 清空集合             |
| int size();                 | 返回包含对象的个数   |
| boolean is Empty();         | 判断是否为空         |

### List集合

#### 基本概念

​	java.util.List集合是Collection集合的子集合，该集合中元素有先后次序且允许重复该集合的主要实现类有:ArrayList类、LinkedList类、Stack类、Vector类等。

​	其中ArrayList类的底层是采用动态数组进行数据管理，访问方便，增删不方便

​	其中LinkedList类的底层是采用链表进行数据管理，增删方便，访问不方便。

​	其中Stack类主要用于描述具有后进先出特征的数据结构，叫做栈，1astin first out该类的底层是采用数组进行数据的管理。

​	其中Vector类的底层采用数组进行数据的管理，与ArrayList类相比属于线程安全的类因此效率比较低，在以后的开发中推荐使用ArrayList类取代之。

#### 常用的方法

​	List除了继承Collection定义的方法外，还根据其线性表的数据结构定义了系列方法，其中最常用的就是基于下标的get和set方法。

| void add(intindex,E element)                      | 向集合中指定位置添加元素 |
| ------------------------------------------------- | ------------------------ |
| boolean addAll(intindex, Collection<?extends E>c) | 向集合中添加所有元素     |
| E get(int index)                                  | 从集合中获取指定位置元素 |
| Eset(intindex,Eelement)                           | 修改指定位置的元素       |
| E remove(int  index)                              | 删除指定位置的元素       |

​	List还提供有类似于String的indexOf和lastIndexOf方法，用于在集合中检索某个对象，其判断逻辑为:(o==null?get(i)==nul:o.equals(get(i)))。

​	toArray方法是继承自Collection的方法，可以将集合中的对象序列以对象数组的形式返回。

```java
List list= new ArrayList();
list.add("one");
list.add ("two");
list.add("three");
String[]array=(String[])list.toArray(newString[]{});
System.out.println(Arrays.toString(array));
```

List的subList方法用于获取子List。

​	需要注意的是，subList获取的List与原List占有相同的存储空间，对子List的操作会影响到原List。

List<E>subList(intfromIndex,int toIndex);

### 泛型机制

#### 基本概念

​	通常情况下集合中可以存放不同类型的对象，本质上是将这些对象全部看做Object类型放入的，因此从集合中取出元素时也是Object类型，为了表达元素最真实的数据类型就需要强制类型转换，而强制类型转换可能发生类型转换异常。

为了避免上述错误的发生，从jdk1.5开始提出泛型机制，也就是在集合名称的右侧使用<数据类型>的方式明确要求该集合可以存放的元素类型，若放入其它类型则编译报错。

如：

List lt1=new LinkedList();

可以放入任意类型对象，取出麻烦

List<String>lt1=new LinkedList<String>();

只能放入String类型，取出方便

#### 泛型机制的概述

​	泛型是Java SE 1.5引入的特性，泛型的本质是参数化类型。在类、接口和方法的定义过程中，所操作的数据类型被传入的参数指定。

```java
public class ArrayList<E>{
    ... ... ...
	public boolean add(E e) {…};
    publicE get(intindex) {…};
}
ArrayList<Sting>list=new ArrayList<Sing>();
list.add("one");
list.add(100);
```

#### 原理分析

​	泛型的本质就是参数化类型，也就是让数据类型作为参数传递，集合定义中的E相当于形式参数负责占位，而使用集合时<>中的数据类型相当于实际参数负责给形式参数初始化当初始化完毕后所有E被替换为实际参数表示的类型进行使用。

​	由于E支持的数据类型非常广泛，因此得名为"泛型”.

如：

```java
//其中i叫做形式参数，负责占位
//int i = 5;
//int i= 10;
public void show(int i){
	...
}
//其中5叫做实际参数，用于给形式参数初始化
show(5);
show(10);
```

## 十四、Java中的数据结构

### Queue集合

#### 基本概念

 	java.uti1.Queue集合是Collection集合的子集合，与List集合是平级关系。
 	该集合的主要实现类是:LinkedList类，因为该类在增删方面有一定的优势。
 	该集合用于描述具有先进先出特征的数据结构，叫做队列(first in first out)。

#### Queue集合的方法

Queue接口中主要方法如下:

| boolean offer(E e) | 将一个对象添加至队尾，若添加成功则返回true |
| ------------------ | ------------------------------------------ |
| E poll()           | 从队首删除并返回一个元素                   |
| E peek()           | 返回队首的元素(但并不删除)                 |

### Set集合

#### 基本概念

​	java.uti1.Set集合是Collection集合的子集合，与List集合以及Queue集合平级关系。

​	该集合与List集合的主要区别在于:元素没有先后次序并且不允许重复的元素。

​	该集合的主要实现类有:HashSet类和TreeSet类。

​	其中HashSet类的底层采用哈希表进行数据管理的。

​	其中TreeSet类的底层采用二叉树进行数据管理的。

#### HashSet集合放入元素的过程

​	将对象加入HashSet集合中时，需要获取对象的哈希码值通过哈希算法索引到对应的存储空间。

**向HashSet中放元素的次序:**

- 先调用元素的hashCode()方法得到哈西码，通过算法计算在哈西表中的位置
- 如果该位置没有元素，直接放入即可。如果该位置有元素，调用元素的equals()方法比较是不是相等。
- 如果相等，则保留旧元素丢弃新元素。
- 如果不相等，则放入该位置的链表中下一个元素。

#### Set集命的遍历

​	所有Collection的实现类都实现了其iterator方法，该方法返回一个lterator接口类型的对象，用于实现对集合元素的迭代遍历。

lterator接口的主要方法有:

| booleanhasNext() | 判断集合中是否有可以迭代/访问的元素 |
| ---------------- | ----------------------------------- |
| E next()         | 用于取出一个元素并指向下一个元素    |
| void remove()    | 用于删除访问到的最后一个元素        |

#### for each结构

**语法格式**

​	for(元素类型变量名:数组名/集合名){

​		循环体;

​	}

**执行流程**
	不断地从数组或集合中取出一个元素并赋值给变量并执行循环体，直到处理完毕所有元素为止。

**总结:**

​	遍历Set集合的方式有三种:toString()、for each结构、迭代器方式。

​	遍历List集合的方式有四种:除了上述3种方式外，还有get方法。

### Map集合

#### 基本概念

java.uti1.Map<K,V>集合中操作元素的基本单位是:单对元素，其中类型参数如下：

​	K——此映射所维护的键(key)的类型

​	V——映射值(value)的类型

该集合中不允许出现重复的键，每个键最多只能映射到一个值。

该集合的主要实现类有:HashMap类和TreeMap类。

其中HashMap类的底层是采用哈希表进行数据管理的。

其中TreeMap类的底层是采用二叉树进行数据管理的。

#### Map集合的常用方法

| V put(K key, V value); | 将Key-Value对存入Map，若集合中已经包含该Key，则替换该Key所对应的Value，返回值为该Key原来所对应的Value，若没有则返回nul |
| ---------------------- | ------------------------------------------------------------ |
| V get(0bject key);     | 返回与参数Key所对应的Value对象，如果不存在则返回null         |

#### Map集合的遍历方式

当处理Map集合中每个元素时需要迭代Map集合，迭代方式一:迭代Key。

```java
map=...//初始化map
Set<Character>keySet =ap.keySet();
	for(lterator<Charactepsi=
    	keySet.iterator();//送代Key
    	i.hasNext();){
    		Characterkey=i.next();
   		 	Integervalue= map.get(key);
            System.out.println(key+":"+value);
		}
```

Map集合的迭代方式二:迭代Entry。

```java
map=..//初始化map
    Set<Entry<Character,Integer>>
    entries=map.entrySet();
for(Entry<Character,Integer>e :entries){
    //ebtries：送代Entry
    Characterkey=e.getKey();
    Integervalue=e.getValue();
    System.out.println(key+":"+value);
}
```

#### Map集合的性能调优

**capacity:**容量,hash表里bucket(桶)的数量,也就是散列数组大小。

**lnitial capacity:**初始容量,创建hash表的时初始bucket的数量,默认构建容量是16.也可以使用特定容量。
**Size:** 大小,当前散列表中存储数据的数量。

**Load factor:**加载因子,默认值0.75(就是75%),当向散列表增加数据时如果size/capacity的值大于Load factor则发生扩容并且重新散列(rehash)。

**性能优化:** 加载因子较小时候散列查找性能会提高,同时也浪费了散列桶空间容量.0.75是性能和空间相对平衡结果,在创建散列表时候指定合理容量,减少rehash提高性能。

#### Map集合的实际应用

- Map集合是面向查询优化的数据结构,在大数据量情况下有着优良的查询性能。
- 经常用于根据key检索value的业务场景。
- **用户登录数据缓冲:**用户名是key,用户对象是value,在登录验证时候根据用户名快速查询用户信息。
- **登录会话状态保持:**在网站编程中,用户会话状态保持经常采用Map存储,可以快速在数以万计的信息中快速确定用户是否已经登录。

## 十五、Java的异常处理机制和文件流

### 异常机制

#### 基本概念

异常就是"不正常"的含义，在Java语言中用于表示运行阶段发生的错误。java.lang.Throwable类是Java语言中所有错误(Error)和异常(Exception)的超类。

其中Error类主要用于描述比较严重无法编码解决的问题，如:JVM挂了。

其中Exception类主要用于描述比较轻微可以编码解决的问题，如:0作为除数。

#### 基本分类

java.lang.Exception类是所有异常类的超类，主要分为以下两大类：

​	RuntimeException-运行时异常，也叫作非检测性异常

​	IOException和其它异常-其它异常，也叫作检测性异常

​		—所谓检测性异常就是在编译阶段能够被编译器检测出来的异常

其中RuntimeException类的主要子类:

​	ArithmeticException //算术异常

​	ArrayIndexOutOfBoundsException //数组下标越界异常

​	NullPointerException //空指针异常

​	ClassCastException //类型转换异常

​	NumberFormatException //数字格式异常

**注意:**
	当程序执行过程中发生异常但没有手动处理时，由Java虚拟机采用默认方式处理，而默认处理方式就是:打印异常名称、异常原因、异常发生的位置等并终止程序。

#### 异常的避免

生以后的开发中尽量使用if条件判断来避免异常的发生

#### 异常的捕获

**语法格式**

try{

编写可能发生异常的语句；

}

catch(异常类型 变量名){

​	编写针对该类异常的处理语句;

}

···

finally{

​	编写无论是否发生异常都应该执行的语句；

}

**注意实现**

​	a、当需要编写多个catch分支时，切记小类型的异常应该放在大类型异常的上面。

简单的写法:

catch(Exception e){.... }

b、finally主要用于编写善后处理的语句，如:关闭已经打开的文件等。

**执行流程**

try{

​	a；

​	b；//可能发生异常的语句

​	c；

}catch(...){

​	d；

}finally {

​	e；

}

当上述程序执行过程没有发生异常时的执行流程:abce;

当上述程序执行过程发生异常时的执行流程:abde;

#### 异常的抛出

**基本概念**

​	在某些特殊情况下产生的异常无法处理或者不便于处理时，就可以将该常转移给该方法的调用者，这种方式就叫做异常的抛出。

语法格式
访问权限 返回值类型 方法名称(形参列表) throws异常类型1，异常类型2,...{}

如：

```java
public void show()throws IOException{}
```

#### 重写方法的抛出规则

如果使用继承时，在父类的某个方法上抛出某些异常，而在子类别中重新定义该方法时注意:

​	不抛出异常

​	抛出父类方法异常中的子类异常

​	抛出和父类一种的异常

重写的方法不可以:

​	抛出同级不一样的异常

​	抛出更大的异常

#### 自定义异常

**基本概念**
	虽然Java官方提供了大量的异常类，但一定不会包含所有开发中可能出现的异常，在Java程序中若需要表达特定问题的特定异常时，就需要程序员自定义异常来描述。

**实现流程**
	自定义xxxxException继承自Exception类或者其子类;

​	提供两个版本的构造方法:无参构造方法和字符串作为参数的构造方法;

#### File类

基本概念
java.io.File类主要用于描述文件和目录的路径信息，可以获取名称、大小等属性信息

常用的方法

File类中常用的方法如下:

| File(String pathname)    | 根据参数指定的路径名来构造对象           |
| ------------------------ | ---------------------------------------- |
| boolean exists()         | 测试此抽象路径名表示的文件或目录是否存在 |
| String getName()         | 返回由此抽象路径名表示的文件或目录的名称 |
| long length();           | 返回由此抽象路径名表示的文件的长度       |
| long lastModified ()     | 返回此抽象路径名表示文件最后一次修改时间 |
| String getAbsolutePath() | 返回此抽象路径名表示文件的绝对路径信息   |
| boolean delete()         | 用于删除文件，当删除目录时要求是空目录   |
| boolean createNewFile()  | 用于创建新的空文件                       |
| boolean mkdir()          | 用于创建目录                             |
| boolean mkdirs(）        | 用于创建多级目录                         |

## 十六、Java的IO流处理

### IO流

#### 基本概念

I/O就是Input/Output的简写，也就是输入输出的含义。
I/O流就是像流水一样不间断地进行输入输出的状态。

#### 基本分类

按照数据读写的基本单位不同分为字节流和字符流。

其中字节流主要指以字节为单位进行读写的流，可以处理任意类型的文件;

其中字符流主要指以字符(2个字节)为单位进行读写的流，只能处理文本文件;

按照数据流动的方向不同分为:输入流和输出流(站在程序的角度)。

其中输入流主要指从文件中读取数据内容输入到程序中，也就是读文件;

其中输出流主要指将程序中的数据内容输出到文件中，也就是写文件;

#### FileOutputStream类

基本概念
java.io.File0utputStream类主要用于将图像数据之类的原始字节流写入输出流中。

常用的构造方法如下：

FileOutputStream(String name)

​	根据参数指定的文件名来构造对象。

FileOutputStream(String name, boolean append)

​	表示以追加的方式根据参数指定的文件名来构造对象。

FileOutputStream类的常用成员方法如下：

| void write(int b)                     | 将指定字节写入此文件输出流。                                 |
| ------------------------------------- | ------------------------------------------------------------ |
| void write(byte[] b, int off,int len) | 将指定字节数组中从偏移量 off开始的len个字节写入此文件输出流。 |
| void write(byte[] b)                  | 将 b.length个字节从指定字节数组写入此文件输出流中            |
| void close()                          | 用于关闭文件输出流并释放有关的资源                           |

BW和BR

#### BufferedWriter类

**概述**

java.io.BufferedWriter类主要用于写入单个字符、字符数组以及字符串到输出流中。
常用的构造方法如下：

BufferedWriter(Writerout)//根据参数指定的引用来构造对象。
	其中Writer类是个抽象类，实参需要传递子类的对象。

BufferedWriter类的常用成员方法如下:

| void write(int c)                           | 用于写入单个字符到输出流中                               |
| ------------------------------------------- | -------------------------------------------------------- |
| void writet（charl[] cbuf,int off, int len) | 用于将字符数组cbuf中从下标off开始的len个字符写入输出流中 |
| void write(char[] cbuf)                     | 用于将字符串数组cbuf中所有内容写入输出流                 |
| void write(String str)                      | 用于将参数指定的字符串内容写入输出流中                   |
| void newLine()                              | 用于写入行分隔符到输出流中                               |
| void close()                                | 用于关闭文件输出流并释放有关的资源                       |

#### BufferedReader类

基本概念java.io.BufferedReader类主要用于从输入流中读取单个字符、字符数组以及一行字符串内容。

#### ObiectOutputStream类

基本概念
java.io.0bject0utputStream类主要用于将Java语言中的对象整体写入输出流中。只能将支持 java.io.Serializable 接口的对象写入流中。类通过实现 iava.io.Serializable 接口以启用其序列化功能。所谓序列化就是指将一个对象相关的所有信息有效组织成字节序列的转化过程

#### Ob ject InputStream类

基本概念
java.io.0bjectInputStream类主要用于从输入流中一次性将一个对象的内容读取出来实现了从字节序列到对象的转化过程，叫做反序列化。

## 十七、Java的多线程处理

### 线程

#### 基本概念

程序  -数据结构+算法，主要指存放在硬盘上的可执行文件，

进程  -主要指运行在内存中的程序。

​	目前主流的操作系统都支持多进程，为了使得操作系统能够同时执行多个任务，但进程是重量级的，新建进程对系统的资源消耗比较大，因此进程的数量比较局限。

​	线程是进程内部的程序流，也就是操作系统中支持多进程，而每个进程的内部又可以支持多线程，线程是轻量级的，新建线程会共享所在进程的系统资源，因此以后的开发中都采用多线程技术。

​	多线程技术采用时间片轮转法实现并发执行，所谓并发就是指宏观并行微观串行。

#### 线程的创建

**创建和启动的方式**

​	java.lang.Thread类用于描述线程，Java 虚拟机允许应用程序并发地运行多个执行线程，而线程的创建和启动方式如下:

- 自定义类继承Thread类并重写run方法，创建该类的实例调用start方法。
- 自定义类实现Runnable接口并重写run方法，创建该类的实例作为实参来构造Thread类型的对象，然后使用Thread类型的对象调用start方法。

**相关方法的解析**

Thread()	-使用无参方式构造对象。

Thread(String name)	-根据参数指定的名称来构造对象。

Thread(Runnable target)	-根据参数指定的接口引用来构造对象。

Thread(Runnable target，String name)	-根据参数指定的引用和名称构造对象。

void run()	-若使用Runnable类型的引用构造出来的对象调用该方法，则最终调用引用所指向对象的run方法，否则调用该方法啥也不做。

void start()	-用于启动线程，Java虚拟机会自动调用该线程的run方法。

**原理分析**

- 执行main方法的线程叫做主线程，执行run方法的线程叫做子线程。
- main方法是程序的入口，最开始只有主线程来依次执行main方法中的代码，当start方法调用成功后，线程的个数瞬间由1个变成了2个，其中子线程去执行run方法，主线程继续执行main方法的代码，两个线程各自独立运行互不影响。
- 当run方法执行完毕后子线程结束，当main方法执行完毕后主线程结束，但两个E线程谁先执行没有明确的规定，取决于操作系统的调度算法。

#### 匿名内部类的方式创建

使用继承加匿名内部类的方式创建

```java
new Thread().{
	public void run(){...}
}.start();
```

使用实现加匿名内部类的方式创建

```java
new Thread(new Runnable(){
    	public void run(){…}
}).start();
```

#### Thread类的常用方法

| int getPriority()          | 用于获取线程的优先级     |
| -------------------------- | ------------------------ |
| void setPriority(int )     | 更改线程的优先级         |
| roid join()                | 等待该线程终止           |
| void join(longmillis)      | 表示等待参数指定的毫秒数 |
| boolean is Daemon（）      | 用于判断是否为守护线程   |
| void setDaemon(boolean on) | 用于设置线程为守护线程   |

### 线程的同步机制

**基本概念**

​	当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要进行线程之间的通信和协调，该机制就叫线程的同步机制。

2003年	存折 和 银行卡	对应同一个账户

**解决方案**

- 由程序结果可知:当两个线程同时进行取款时，导致最终的账户余额不合理。
- 引发原因:线程一还没有执行完毕取款操作，此时线程二已经开始取款操作。
- 解决方案:让两个线程的并发操作改为串行操作即可，也就是依次执行取款操作。
- 方案的缺点:若依次启动多个线程则导致多线程的意义不复存在。

​	在Java语言中使用synchronized关键字来实现同步/对象锁机制，来保证线程执行该段代码时的原子性(要么不执行，要么就执行完整)，具体方式如下:

**第一种实现方式**

使用同步代码块的方式实现部分代码的锁定，格式如下：

​	synchronized(类类型的引用){

​		编写所有需要锁定的代码；

​	}

**第二种实现方式**

使用同步方法的方式实现所有代码的锁定。

直接使用synchronized关键字来修饰整个方法即可

该方式等价于:
synchronized(this){整个方法体的代码}

#### 原理分析

​	当多个线程调用start方法后同时去抢占共享资源，由于同步锁的存在导致只有一个线程能够抢到共享资源并进行加锁处理，其它没有抢到共享资源的线程进入阻塞状态，当该线程执行完毕所有锁定的代码后自动释放同步锁，此时阻塞状态的所有线程继续抢占共享资源，抢不到的线程再次回到阻塞状态。

**实现的注意方式**

使用synchronized保证线程同步应当注意:

-  多个需要同步的线程在访问该同步块时，看到的应该是同一个所对象引用。
-  在使用同步块时应当尽量减少同步范围以提高并发的执行效率。

#### 线程安全类和线程不安全类

- StringBuffer是同步的 synchronized append()；
- StringBuilder不是同步的append();
- Vector和 Hashtable是同步的
- ArrayList和 HashMap不是同步的
- Collections.synchronizedList()
- Collections.synchronizedMap()

**静态方法的锁定**

- 当我们对一个静态方法加锁，如:

  public synchronized static void xxx(){…..}

- 那么该方法锁的对象是类对象。每个类都有唯一的一个类对象。获取类对象的方式:类名.class。

- 静态方法与非静态方法同时声明了synchronized，他们之间是非互斥关系的。原因在于，静态方法锁的是类对象而非静态方法锁的是当前方法所属对象。

**死锁的概念**

- 当两个线程或多个线程之间互相锁定时就形成了死锁。

  避免死锁的原则:

- 顺序上锁，反向解锁，不要回头

线程一执行的代码:

```java
public void run(){
    synchronized(a){
        //持有同步锁a，等待同步锁b
        synchronized(b){
            ...
        }
    }
}
```

线程二执行的代码:

```java
public void run(){
    synchronized(b){
        //持有同步锁b，等待同步锁a
        synchronized(a){
            ...
        }
    }
}
```

## 十八、Java网络编程socket

### 网络编程的常识

#### 七层网络模型

IS0(国际标准委员会组织)将数据的传递从逻辑上划分为以下七层:

​	应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

当发送数据时，需要对发送的内容按照上述七层模型进行层层加包再发送出去;

当接收数据时，需要对接受的内容按照上述七层模型相反的次序层层拆包再解析出来

#### IP地址

如:
192.168.1.1-是绝大多数路由器的登录地址，进行账号密码的配置以及Mac地址过滤

IP地址-是互联网中的唯一标识，用于定位到具体某一台设备。

IP地址本质上是由32位二进制组成的整数，叫做IPv4，当然也有128位二进制组成的整数，叫做IPv6，目前主流的还是IPv4.

​	日常生活中采用点分十进制表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。
如:
0x01020304 =>1.2.3.4

#### 端口号的概述

IP地址可以定位计算机，但计算机中有多个进程，每个进程都有自己进程id。

端口号就是用来绑定进程ID的，每个端口号代表一个进程。

端口号的范围:0-65535。

端口分类:
公认端口(WellKnown Ports):这类端口也常称之为"常用端口"。

这类端口的端口号从0到1024，通产紧密绑定于一些特定的服务不建议使用。

特殊的端口:
HTTP:80 	FTP:21	MySQL:3306	Oracle:1521	Tomcat:8080

### 基于tcp协议的编程模型

#### 编程模型

服务器:

(1)创建ServerSocket类型的对象并提供端口号;

(2)等待客户端的连接请求，调用accept方法;

(3)使用输入输出流进行通信;(4)关闭Socket;

客户端:
(1)创建Socket类型的对象并提供服务器的IP地址和端口号:

(2)使用输入输出流进行通信;

(3)关闭Socket;

#### C/S架构的简介

- 在C/S模式下客户向服务器发出服务请求，服务器接收到请求后提供相应服务。
- 例如:在一个酒店中，顾客想服务员点菜,服务员把点菜单通知厨师，厨师按点菜单做好菜后让服务员端给客户，这就是一种C/S工作方式。如果把酒店看作一个系统，服务员就是客户端，厨师就是服务器。这种系统分工和协同工作的方式就是C/S的工作方式。
- 客户端部分:为每个用户所专有的，负责执行前台功能
- 服务器部分:由多个用户共享的信息与功能，招待后台服务

#### ServerSocket类的概述

java.net.ServerSocket类主要用于描述服务器套接字信息。

常用的方法如下:

| ServerSocket(int port) | 根据参数指定的端口号来构造对象 |
| ---------------------- | ------------------------------ |
| Socket accept()        | 侦听并接收到此套接字的连接请求 |
| void close（）         | 用于关闭套接字                 |

#### Socket类的概述

java.netSocket类主要用于描述客户端套接字，是两台机器间通信的端点。

常用的方法如下:

| Socket(Stringhost,int port)    | 根据指定主机名和端口来构造对象 |
| ------------------------------ | ------------------------------ |
| InputStream getlnputStream()   | 用于获取当前套接字的输入流     |
| OutputStream getOutputStream() | 用于获取当前套接字的输出流     |
| void close()                   | 用于关闭套接字                 |

## 十九、Java常用的设计模式

### 常用的设计原则

#### 软件开发的流程

​	需求分析文档=>概要设计文档 =>详细设计文档=>编码和测试 =>安装和调试=>维护和升级

**常用的设计原则**

开闭原则-对扩展开放，对修改关闭。

​		-提高了代码的扩展性和维护性。

如：

```java
public class Person{
    private String name;
    private int age;
    ...
}
public class SubPerson extends Person{
    private boolean gender;
    ...
}

```

**里氏代换原则**

-任何父类可以出现的地方，子类一定可以出现

-子类 is a 父类。

-在以后的开发中多使用继承和多态的理念。

如：

```java
public static void draw(Shape s){
    s.show();
}
ShapeTest.draw(new Rect(1,2,3,4));
ShapeTest.draw(new Circle(5,6,7));
```

**依赖倒转原则**

-尽量多依赖于抽象类和接口，而不是具体实现类。
-在以后的开发中多使用抽象类和接口，对子类具有强制性和规范性。

如：

```java
public abstract class Account{
    public abstract double getLixi()；
}
public class FixedAccount extends Account{
    @Override
    public double getLixi(){}
}
```

**接口隔离原则**

- 尽量依赖于小接口而不是大接口，避免接的污染。
- 可以降低耦合度。
- 耦合主要指一个模块与其它模块之间的关联度

如：

```java
public interface RunAnimal{
    public abstract void run();// 描述奔跑的行为
}
public interface FlyAnimal{
    public abstract void fly();// 描述飞行的行为
}
public class Dog implements RunAnimal{
    public void run(){...}
}
```

**迪米特法则**

- 一个实体应当尽量少于其它实体之间发生相互作用。
- 低耦合，高内聚。
- 高内聚就是指将一个实体应当将该实体应该拥有的功能尽量聚集在该实体内部。

**合成复用原则**

尽量多使用合成的方式，而不是继承的方式。

如：

```java
public class A{
    public void show(){...}
    ...	...
}
public class B	extends A{
  @Override
    public void show() {
        System.out.println("B's show method");
    }

    public void test() {
        // 调用B类重写后的show方法
        show();
        // 调用父类A的show方法
        super.show();
    }
}
```

**常用的设计模式**

基本概念

​	设计模式就是一种用于固定场合的固定套路，是多年编程经验的总结。

常用的设计模式

​	单例设计模式、模板设计模式、工厂方法模式、抽象工厂模式。

#### 工厂模式的类型

**简单工厂模式（Simple Factory Pattern）**：

- 简单工厂模式不是一个正式的设计模式，但它是工厂模式的基础。它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。

**工厂方法模式（Factory Method Pattern）**：

- 工厂方法模式定义了一个创建对象的接口，但由子类决定实例化哪个类。工厂方法将对象的创建延迟到子类。

**抽象工厂模式（Abstract Factory Pattern）**：

- 抽象工厂模式提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。

#### 冒泡排序：

**（1）原理：**

- 1、从第一个数据开始，与第二个数据相比较，如果第二个数据小于第一个数据，则交换两个数据的位置。
- 2、指针由第一个数据移向第二个数据，第二个数据与第三个数据相比较，如果第三个数据小于第二个数据，则交换两个数据的位置。
- 3、依此类推，完成第一轮排序。第一轮排序结束后，最大的元素被移到了最右面。
- 4、依照上面的过程进行第二轮排序，将第二大的排在倒数第二的位置。
- 5、重复上述过程，没排完一轮，比较次数就减少一次。

**（2）例子：**

待排序数据：7, 6, 9, 8, 5,1

第一轮排序过程：

```
指针先指向7，7和6比较，6<7，交换6和7的位置，结果为：6,7,9,8,5,1
指针指向第二个元素7，7和9比较，9>7，不用交换位置，结果仍为：6,7,9,8,5,1
指针指向第三个元素9，比较9和8，8<9，交换8和9的位置，结果为：6,7,8,9,5,1
指针指向第四个元素9，比较9和5，5<9，交换5和9，结果为：6,7,8,5,9,1
指针指向第五个元素9，比较9和1，1<9，交换1和9的位置，结果为6,7,8,5,1,9
```

第一轮排序结束后，最大的数字9被移到了最右边。

进行第二轮排序，过程同上，只是由于最大的9已经放在最右边了，因此不用在比较9了，少了一次比较，第二轮结束的结果为：6,7,5,1,8,9

第三轮结果：6,5,1,7,8,9

第四轮比较结果：5,1,6,7,8,9

第五轮比较结果：1,5,6,7,8,9

最终排序结果为：1,5,6,7,8,9，由上可知N个数据排序，需要进行N-1轮排序；第i轮排序需要的比较次数为N-i次。

**（3）编码思路：**

需要两层循环，第一层循环i表示排序的轮数，第二层循环j表示比较的次数。

**代码实现：**

实例：

```java
package com.test.insertsort;
/**
 * 选择排序
 * @author Administrator
 *
 */
public class ChooseSort {
    private int[] array;
    private int length;
    
    public ChooseSort(int[] array){
        this.array = array;
        this.length = array.length;
    }
    
    /**
     * 打印数组中的所有元素
     */
    public void display(){
        for(int i: array){
            System.out.print(i+" ");
        }
        System.out.println(); 
    }
    
    /**
     * 选择排序算法
     */
    public void chooseSort(){
        for(int i=0; i<length-1; i++){
            int minIndex = i;
            for(int j=minIndex+1;j<length;j++){
                if(array[j]<array[minIndex]){
                    minIndex = j;
                }
            }
            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp; 
        }
    }
    
    public static void main(String[] args){
        int[] array={100,45,36,21,17,13,7};
        ChooseSort cs = new ChooseSort(array);
        System.out.println("排序前的数据为：");
        cs.display();
        cs.chooseSort();
        System.out.println("排序后的数据为：");
        cs.display();
    }
}
```

**（5）选择排序总结：**

N个元素需要排序N-1轮；

第i轮需要比较N-i次；

N个元素排序，需要比较n（n-1）/2次；

选择排序的算法复杂度仍为O（n*n）；

相比于冒泡排序，选择排序的交换次数大大减少，因此速度要快于冒泡排序

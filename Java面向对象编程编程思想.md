# 二.Java面向对象编程编程思想

## 1.理解面向对象思想和概念

### 1.1面向对象编程的概念

**1.1.1 什么事对象？**

​	万物皆对象。

**1.1.2 什么是面向对象？**

​	面向对象就是指以特征(属性)和行为的观点去分析现实世界中事物的方式。

**1.1.3 什么是面向对象编程**

​	面向对象编程就是指先使用面向对象的 方式进行分析，再使用任意一门面向对象的编程语言进行翻译的过程。

​	其中C语言是一门面向过程的编程语言。

​	其中C++语言是一门既面向过程又面向对象的编程语言。

​	其中Java语言是一门纯面向对象的编程语言。

**1.1.4 如何学好面向对象编程？**

​	深刻理解面向对象编程的三大特征:封装、继承、多态。

### 1.2 类、对象以及引用

**1.2.1 对象和类的概念**

​	对象是客观存在的实体，在Java语言体现为内存空间的一块区域。

​	类就是分类的概念，是对具有相同特征和行为的多个对象共性的抽象描述，在Java语言中包含描述特征的成员变量和描述行为的成员方法。

**1.2.2 类的定义**

（1）类的定义语法格式

​	class 类名{

​		类体；

​	}

注意：当类名由多个单词组成时，要求每个单词的首字母都要大写。

（2）成员变量的语法格式

​	class 类名{

​		数据类型 成员变量名 = 初始值；——其中 = 初始值通常省略，但分号不能省略

​	}

​	局部变量 - 主要指在方法体中声明的变量，作用范围从声明开始到方法体结束。

​	成员变量 - 主要指在方法体外类体内声明的变量，作用范围从声明到类体结束。

注意：当成员变量名由多个单词组成时，要求从第二个单词起每个单词首字母大写（驼峰命名法）。

**1.2.3 对象的创建**

（1）语法格式

​	new 类名();

（2）注意事项

​	a.当一个类定义完毕后，使用new关键字创建/构造对象的过程叫做 类的实例化。

​	b.创建对象的本质就是在内存中的堆区申请存储空间，来存放该对象独有的特征信息。

**1.2.4 引用**

（1）基本概念

​	在Java语言中使用引用数据类型声明的变量叫做引用型变量，简称为"引用。

​	引用变量主要用于记录对象在堆区中的内存地址信息，便于下次访问。

（2）语法格式

​	类名 引用变量名；

Java程序示例：

```java
public class Test {
	String name;
    int age;
    public static void main(String[] args) {
    	Text t = new Text();
        t.name = "zhangsan";
        t.age = 18;
        System.out.println(t.name,t.age);
    }
}
```

### 1.3 成员方法

**1.3.1 语法格式**

​	class{

​		返回值类型 成员方法名(形参列表){

​			成员方法体；

​		}

​	}

注意：当成员变量名由多个单词组成时，通常要求从第二个单词起每个单词首字母大写。

**1.3.2 格式详解**

（1）返回值类型

​	返回值主要指从方法体内向方法体外返回的数据内容。

​	返回值类型主要指返回值的数据类型，可以是基本数据类型，也可以是引用数据类型。

​	在方法体中使用`return`关键字来返回数据内容并结束当前方法。

​	若该方法无需返回任何数据内容，则返回值类型写`void`即可。

（2）形参列表

​	形式参数主要将方法体外的数据传入到方法体内部，格式：数据类型 形参名。

​	形参列表主要指多个形式参数组成的整体，格式：数据类型 形参名1，数据类型 形参名2，……

​	若该方法不需要传入任何数据内容时，则形参列表不写即可。

（3）成员方法体

​	成员方法体主要编写描述该方法功能的语句。

**1.3.3 方法的调用**

（1）语法格式

​	引用变量名.成员方法名（实参列表）；

（2）注意事项

​	a.实际参数列表主要用于对形式参数列表进行初始化操作，因此参数的个数、类型、顺序等都必须形参列表保持一致。

​	b.实参可以传递直接量、变量、表达式以及方法的调用等。

Java程序示例：

```java
public class Test {
	String name;
    int age;
    public static void main(String[] args) {
    	Text t = new Text();
        t.name = "zhangsan";
        t.age = 18;
        t.show();
        t.setName("lisi");
        t.show();
        t.setAge(20);
        t.show();
        String n1 = t.getName();
        System.out.println(n1);
        int i1 = t.getAge();
        System.out.println(i1);
    }
    //成员方法中可以直接访问成员变量
    void show(){
        System.out.println(name +","+ age);
    }
    //将成员变量name修改为参数指定数值
    void setName(String s){
        name = s;
    }
    //将成员变量age修改为参数指定数值
    void setAge(int i){
        age = i;
    }
    String getName(){
        return name;
    }
    int getAge(){
        return age;
    }
}
```

## 2.构造方法及方法重载

### 2.1构造方法和方法重载

**2.1.1构造方法**

（1）语法格式

​	class 类名{

​		类名（形参列表）{

​			构造方法体；

​		}

​	}

（2）注意事项

​	a.构造方法的名称与类名完全相同，没有返回值类型连void都不许有。

​	b.当使用new关键字构造对象时会自动调用构造方法进行成员变量的初始化工作。

（3）默认构造方法

​	a.当一个类中没有自定义任何形式的构造方法时，编译器会自动添加一个无参的空构造方法，叫做默认/缺省构造方法。

​	b.若类中出现自定义构造方法，则编译器不再提供任何形式的构造方法。

**2.1.2 方法的重载**

（1）基本概念

​	在Java语言中若方法的名称相同但参数列表不同，这样的方法之间构成重载关系。

（2）体现形式

​	方法重载的主要形式有:参数的个数不同、参数的类型不同、参数的顺序不同，与形参变量名和返回值类型无关，但建议返回值类型最好相同。

​	判断方法是否重载的核心：调用能否区分。

Java程序示例：

```java
public class Test {
    // 方法1: 无参数
    public void print() {
        System.out.println("无参数方法");
    }
    
    // 方法2: 一个int参数（与方法1参数个数不同）
    public void print(int ia) {
        System.out.println("int参数: " + ia);
    }
    
    // 方法3: 一个String参数（与方法2参数类型不同）
    public void print(String sa) {
        System.out.println("String参数: " + sa);
    }
    
    // 方法4: 两个int参数（与方法2参数个数不同）
    public void print(int ia, int ib) {
        System.out.println("两个int参数: " + ia + ", " + ib);
    }
    
    // 方法5: int和String参数（参数顺序不同也构成重载）
    public void print(int ia, String sa) {
        System.out.println("int和String参数: " + ia + ", " + sa);
    }
    
    // 方法6: String和int参数（与方法5参数顺序不同）
    public void print(String sa, int ia) {
        System.out.println("String和int参数: " + sa + ", " + ia);
    }
}
```

**2.2 this关键字**

**2.2.1 基本概念**

​	在构造方法中this关键字代表当前正在构造的对象。

​	在成员方法中this关键字代表当前正在调用的对象。

原理分析：当成员方法中访问成员变量时默认会加上this.(相当于汉语中"我的”)，当不同的引用调用同一个成员方法时会导致成员方法中的this不同，那么this.访问的结果随之不同。

Java程序示例：

```java
public class Test {
    private String name;  // 实例变量
    
    public void setName(String name) {  // 参数是局部变量
        this.name = name;  // 使用this区分
    }
    
    public String getName() {
        return this.name;  // 明确引用实例变量
    }
}
```

**2.2.2 使用方试**

（1）当使用形参和成员变量名同名时，在构造方法或成员方法中通常优先使用形参变量，若希望使用成员变量就需要在变量名的前面加上this.进行说明。

（2）在构造方法的第一行使用this(实参)的方式可以调用本类中的其它构造方法。

### 2.3 方法的传参和递归调用过程

**2.3.1 方法的传参过程**

理解内容：

（1）main方法是程序的入口，为main方法中的局部变量开辟内存空间并初始化。

（2）调用max方法时为max方法的形参变量开辟内存空间。

（3）使用实参变量给形参变量进行赋值操作，执行max方法的方法体。

（4）当max方法结束后释放形参变量的内存空间。

（5）main方法中的res得到max方法的返回值然后继续向下执行。

（6）当main方法结束后释放局部变量的内存空间。

掌握内容：

（1）当基本数据类型的变量作为方法的参数传递时，形参变量的改变不会影响到实参。

（2）当引用数据类型的变量作为方法的参数传递时，形参变量指向的内容发生改变后会影响到实参变量指向的内容。

（3）当引用数据类型的变量作为方法的参数传递时，形参变量改变指向后再改变指向的内容时不会影响到实参变量指向的内容;

**2.3.2 递归调用**

（1）基本概念

​	在一个方法体的内部调用当前方法自身的形式，叫做递归。

Java程序示例：

```java
public class Test {
    // 递归计算阶乘
    public static int factorial(int n) {
        if (n <= 1) {  // 基线条件
            return 1;
        }
        int fi = n * factorial(n - 1);
        System.out.println(fi);
        return fi;  // 递归调用
    }

    public static void main(String[] args) {
        System.out.println("5的阶乘: " + factorial(5));  // 120
    }
}
```

（2）注意事项

​	a.必须找到递归的规律和退出条件。

​	b.使用递归使得问题简单化而不是复杂化。

​	c.若递归影响到程序的执行性能则使用递推取代之。

## 3.面向对象的封装特性和static关键字

### 3.1 封装

**3.1.1 基本概念**

​	封装是面向对象编程的三大特性之一，它通过将数据和对数据的操作捆绑在一起，并限制对数据的直接访问来提高代码的安全性和可维护性。

​	通常情况下测试类可以对封装类中的成员变量进行赋值，若赋值的数据合法但不合理时无论时编译阶段还是运行阶段都不会报错或者给出提示，此时与现实生活不符。

​	为了避免上述错误的发生，就需要对成员变量进行密封包装处理，该机制就叫做封装换句话说，封装就是一种保证成员变量值合理性的机制。

**3.1.2 实现流程**

（1）私有化成员变量，使用private关键字修饰。

（2）提供公有的get和set方法，在方法体中进行合理值的判断。

（3）在构造方法中调用set方法进行合理值的判断。

Java程序示例：

```java
public class Test {
    // 私有字段(private修饰)
    private String name;
    private int age;
    private double score;

    // 公开的getter方法
    public String getName() {
        return name;
    }

    // 公开的setter方法，可添加验证逻辑
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("姓名不能为空");
        }
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age < 0 || age > 120) {
            throw new IllegalArgumentException("年龄无效");
        }
        this.age = age;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException("分数必须在0-100之间");
        }
        this.score = score;
    }

    // 公开的业务方法
    public String getGrade() {
        if (score >= 90) return "A";
        else if (score >= 80) return "B";
        else if (score >= 70) return "C";
        else if (score >= 60) return "D";
        else return "F";
    }
}
```

### 3.2 static关键字

**3.2.1基本概念**

​	通常情况下成员变量隶属于对象层级，每创建一个对象就需要申请独立的内存空间来存放该对象独立的成员变量信息，若所有对象的某个成员变量数值完全一样却又单独存放会造成内存空间的浪费。

​	为了解决上述问题，则使用static关键字修饰成员变量，此时该成员变量由对象层级提升为类层级被所有对象共享，该成员变量随着类的加载准备就绪，与是否创建对象无关。

​	static关键字也可以修饰成员方法，推荐使用<类名.>的方式访问。

**3.2.2 使用方法**

（1）在非静态的成员方法中既能访问非静态的成员也能访问静态的成员。(成员:成员变量+成员方法，静态成员被所有对象共享)

（2）在静态的成员方法中只能访问静态的成员不能访问非静态的成员。(成员:成员变量+成员方法，调用静态方法时可能还没有创建对象)

（3）只有隶属于类层级被所有对象共享的内容才可以使用static修饰。(不能滥用static关键字)

**3.2.3 单例设计模式**

（1）基本概念

​	在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类。

​	而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。

（2）实现流程

​	a.私有化构造方法，使用private关键字修饰。

​	b.声明本类类型的引用指向本类类型的对象，使用private static共同修饰。

​	c.提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰。

（3）实现方式

​	单例设计模式的实现方式有两种：饿汉式 和 懒汉式，推荐使用饿汉式。

## 4.面向对象的继承特性和final关键字

### 4.1 继承

**4.1.1 基本概念**

​	当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式叫做继承。

​	使用继承可以提高代码的复用性和扩展性以及可维护行。

​	在Java语言中使用extend是（扩展）关键字来表达继承关系。

**4.1.2 注意事项**

（1）子类可以继承父类的成员变量和成员方法，其中私有成员变量可以继承但不可以直接使用，子类不可以继承父类的构造方法和私有方法。

（2）无论使用何种方式构造子类对象时，都会自动调用父类中的无参构造方法来初始化从父类中继承下来的成员变量，相当于在子类构造方法第一行增加代码:super()的效果

（3）使用继承必须满足 子类 is a 父类 的逻辑关系，也就是不能滥用继承。

（4）Java语言中只支持单继承不支持多继承，也就是一个子类只能有一个父类，但一个父类可以有多个子类。

**4.1.3 方法的重写**

（1）基本概念

​	若从父类中继承下来的方法不满足子类的需求时，就需要在子类中重新写一个与父类中方法一样的方法来覆盖从父类中继承的版本，这种方式就叫做重写。

（2）重写的原则

​	a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型。

​	b.要求方法的访问权限不能变小，可以相同或者变大。

​	c.要求不能抛出更大的异常。

### 4.2访问控制

**4.2.1 常用的访问控制符**

| 访问控制符 | 访问权限 | 本类 | 本包中的类 | 子类 | 其他包中的其他类 |
| :--------: | :------: | :--: | :--------: | :--: | :--------------: |
|   public   |  公有的  |  ok  |     ok     |  ok  |        ok        |
| protected  |  保护的  |  ok  |     ok     |  ok  |        on        |
|  private   |  私有的  |  ok  |     no     |  no  |        no        |
|  啥也不写  |  默认的  |  ok  |     ok     |  no  |        no        |

**4.2.2 包的定义**

​	package 包名;

​	package 包名1.包名2...包名n; - 便于管理，避免命名冲突的问题。

### 4.3 final关键字

**4.3.1 基本概念**

​	final本意为"最终的，不可更改的"，该关键字可以修饰类、成员方法、成员变量等。

**4.3.2 使用方式**

​	final关键字修饰类表示该类不能被继承。（ 为了防止滥用继承带来的危害）

​	final关键字修饰成员方法表示该方法不能被重写但可以被继承。（为了防止不经意间造成的方法重写）

​	final关键字修饰成员变量表示该成员变量必须初始化而且不能更改。（为了防止不经意间造成数值的更改）

扩展：

​	在以后的开发中很少单独使用static关键字或final关键字修饰成员变量，通常都是使用public static final共同修饰成员变量来表达常量的含义，常量的，命名规则是：要求所有字母大写，不同之间采用下划线连接。

## 5.面向对象的多态特性及抽象类和接口

### 5.1多态

**5.1.1 基本概念**

​	多态主要指同一种事物表现出来的多种形态。

**5.1.2 语法格式**

​	父类类型 引用变量名 = new 子类类型（）；

**5.1.3 多态的效果**

（1）当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有的方法。

（2）当父类的引用指向子类的对象时，父类的引用不可以直接调用子类独有的方法。

（3）对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类重写以后的版本。

（4）对于父子类都有的静态方法来说，编译和运行阶段调用父类版本，隶属于类层级，因此与指向的对象无关。

**5.1.4 引用数据类型之间的转换**

（1）引用数据类型之间的转换分为:自动类型转换和强制类型转换。

​	其中自动类型转换主要指从小范围到大范围之间的转换，也就是子类到父类的转换。

​	其中强制类型转换主要指从大范围到小范围之间的转换，也就是父类到子类的转换。

（2）引用数据类型之间的转换必须发生在父子之间，否则编译报错。

（3）若转换到的目标类型是子类类型但不是该引用真正指向的子类类型，则编译通过，运行阶段发生类型转换异常。

（4）为了避免上述错误的发生，可以使用`instanceof`进行判断，具体格式如下：
	`if(引用变量名 instanceof 数据类型) - 判断引用变量指向的对象是否为后面的类型`

**5.1.5 多态的意义**

​	多态的实际意义在于可以屏蔽不同子类的差异性实现通用的编程，但可以调用不同的方法带来不同的结果。

（1）允许添加新功能而不修改现有代码。

（2）不同对象通过统一接口操作。

（3）减少类之间的直接依赖关系。

（4）子类对象可替代父类对象使用。

（5）许多设计模式基于多态实现。

（6）使代码更清晰、更易于理解和维护。

多态的使用场合：

​	a.通过方法的参数传递形成的多态。

​	b.在方法体中直接使用多态的语法格式。

Java程序示例：

```java
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪汪");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵喵");
    }
}

public class PolymorphismExample {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // Animal对象
        Animal myDog = new Dog();       // Dog对象
        Animal myCat = new Cat();       // Cat对象
        
        myAnimal.makeSound();  // 输出: 动物发出声音
        myDog.makeSound();     // 输出: 汪汪汪
        myCat.makeSound();     // 输出: 喵喵喵
    }
}
```

### 5.2 抽象类

**5.2.1 抽象方法的概念**

​	抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰。

语法格式:

​	访问控制符 abstract 返回值类型 方法名称（形参列表）；

**5.2.2 抽象类的概念**

​	抽象类就是指不能具体实例化的类，也就是不能创建对象并使用abstract 关键字修饰。

**5.2.3 注意事项**

（1）抽象类中可以有成员变量、构造方法以及成员方法。

（2）抽象类中不一定有抽象方法。

（3）拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并且使用abstract关键字修饰的类才算真正意义上的抽象类。

**5.2.4 实际意义**

​	抽象类的意义不在于自身创建对象而在于被继承，当一个类继承抽象类后必须重写抽象类中的抽象方法，否则该类也变成抽象类。也就是说抽象类对子类具有强制性和规范性，因此叫做模板设计模式。

> [!TIP]
>
> ​	在以后的开发中推荐使用多态的语法格式，当父类的引用指向子类的对象时，那么父类引用直接调用的所有方法一定是父类拥有的方法，若希望更换子类时，只需要将new关键字后面的类型修改而其它地方无需更改立即生效，从而提高了代码的可维护性。该方式的缺点就是:父类引用不能直接访问子类独有的方法，若访问则需要强转。


Java程序示例：
```java
// 抽象类定义
public abstract class Animal {
    // 成员变量
    private String name;
    
    // 构造方法
    public Animal(String name) {
        this.name = name;
    }
    
    // 具体方法
    public String getName() {
        return name;
    }
    
    // 抽象方法（没有方法体）
    public abstract void makeSound();
    
    // 另一个具体方法
    public void sleep() {
        System.out.println(name + "正在睡觉");
    }
}
```



### 5.3 接口

**5.3.1 基本概念**

​	接口就是一种比抽象类还抽象的类，体现为所有成员方法都是抽象方法。

​	定义类的关键字是class，而定义接口的关键字是interface。

​	继承类的关键字是extends，而实现接口的关键字是implements。

Java程序示例：

```java
public interface Vehicle {
    // 抽象方法
    void start();
    
    // 默认方法
    default void stop() {
        System.out.println("车辆停止");
    }
}
```

**5.3.2 类社接口之间的关系**

|     类和类之间的关系     |     使用extends关键字表达继承的关系     |   支持单继承   |
| :----------------------: | :-------------------------------------: | :------------: |
|  **类和接口之间的关系**  | **使用`implemets`关键字表达实现的关系** | **支持多实现** |
| **接口和接口之间的关系** |    **用extends关键字表达继承的关系**    | **支持多继承** |

**5.3.3 抽象类和接口的区别**

（1）定义抽象类的关键字是abstract class，而定义接口的关键字是interface。

（2）继承抽象类的关键字是extends，而实现接口的关键字是implements。

（3）继承抽象类支持单继承，而实现接口可以多实现。

（4）抽象类中可以有构造方法，而接口中不可以有构造方法。

（5）抽象类中可以有成员变量，而接口中只可以有常量。

（6）抽象类中可以有成员方法，而接口中只可以有抽象方法。

（7）抽象类中增加方法可以不影响子类，而接口中增加方法通常都影响子类。

（8）从jdk1.8开始允许接口中出现非抽象方法，但需要使用`defauit`关键字修饰。

Java程序示例：

```java
public interface SortingStrategy {
    void sort(int[] array);
}

public class BubbleSort implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        // 冒泡排序实现
    }
}

public class QuickSort implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        // 快速排序实现
    }
}

public class Sorter {
    private SortingStrategy strategy;
    
    public void setStrategy(SortingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sortArray(int[] array) {
        strategy.sort(array);
    }
}
```

### 5.4 匿名内部类

5.4.1 语法格式

​	接口/父类类型 引用变量名 = new 接口/父类类型（）{方法的重写}；

5.4.2 建议

​	当接口类型的引用作为方法的形参时，实参的传递方式有两种:

​		a.自定义类实现接口，然后创建该类的对象作为实参传递。

​		b.使用匿名内部类的语法格式来得到接口类型的引用作为实参传递。

### 5.5 内部类

**5.5.1 基本概念**

​	当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类，而这个内部类所在的类叫做外部类。

**5.5.2 语法格式**

​	class 外部类名{

​		class 内部类名{

​			内部类的类体；

​		}

​	}

**5.5.3 实际作用**

当一个类存在的价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为所服务类中的内部类，这样可以隐藏该类的实现细节并且可以方便的访问外部类的私有成员而不再需要提供公有的get和set方法。

**5.5.4 基本分类**

​	普通内部类 - 直接将一个类的定义放在另一个类的类体中。

​	静态内部类 - 使用static关键字修饰的内部类，隶属于类层级。

​	局部内部类 - 直接将一个类的定义放在方法体内部时，作用范围是从声明开始一直到方法体结束


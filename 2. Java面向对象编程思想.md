# 理解面向对象思想和概念

## 1. 面向对象编程的概念(理解)

#### 1.1 什么是对象？

​	万物皆对象

#### 1.2 什么是面向对象？

​	面向对象就是指以特征 (属性) 和行为的观点去分析现实世界中事物的方式。

#### 1.3 什么是面向对象编程？

​	面向对象编程就是指先使用面向对象的方式进行分析，再使用任意一门面向对象的编程语言进行翻译的过程。

​	其中C语言是一门面向过程的编程语言。

​	其中C++语言是一门既面向过程又面向对象的编程语言。

​	其中Java语言是一门纯面向对象的编程语言。

#### 1.4 如何学好面向对象编程？

​	深刻理解面向对象编程的三大特征：封装、继承、多态。



## 2.类、对象以及引用(抽象、难点、重中之重)

#### 2.1 对象和类的概念

​	对象是客观存在的实体，在Java语言体现为内存空间的一块区域。

​	类就是分类的概念，是对具有相同特征和行为的多个对象共性的抽象描述，在Java语言中包含描述特征的成员变量和描述行为的成员方法，是创建对象的模板。

#### 2,2 类的定义

##### 	(1). 类定义的语法格式

​		class 类名 {

​			类体；

​		}

​	如：

​		class Person {

​		}

​	**注意：**当类名由多个单词组成时， 要求每个单词的首字母都要大写；

##### 	(2). 成员变量定义的语法格式

​		class 类名 {

​			数据类型  成员变量名  =  初始值； //  其中 = 初始值通常省略，但分号不能省略

​		}

​		如:

​			class Person {

​				String name;

​				int age;

​			}

​		**注意：**

​			当成员变量名由多个单词组成时，要求从第二个单词起每个单词首字母大写；

​		**扩展:**

​			I. 局部变量主要指在方法体中声明的变量，作用范围从声明开始到方法体结束

​			II. 成员变量主要指在方法体外类体内声明的变量，作用范围从声明到类体结束

#### 2.3 对象的创建

##### 	(1). 语法格式

​		new 类名 ( ) ;

​	如：

​		new Person( ); 	 创建Person类型的对象，由于该对象没有名字因此叫做“匿名对象”

##### 	(2). 注意事项

​		I. 当一个类定义完毕后，使用new关键字创建/构造对象的过程叫做 类的实例化;

​		II. 创建对象的本质就是在内存中的堆区申请存储空间，来存放该对象独有的特征信息

#### 2.4 引用

##### 	(1). 基本概念

​		在Java语言中使用引用数据类型声明的变量叫做引用型变量，称为"引用”。

​		引用变量主要用于记录对象在堆区中的内存地址信息，便于下次访问。

##### 	(2). 语法格式

​		类名 引用变量名;

​	如：

​		Person p;	 表示声明Person类型的引用变量p，本质上在栈区申请存储空间

​		Person p = new Person();	表示声明引用变量p来记录Person类型对象的地址信息

​		引用变量名.成员变量名；

​	如：

​		p.name = "zhangsan";	表示使用引用变量p访问所指向堆区对象的姓名特征

实例

```
public class Person {
	String name;	// 用于描述姓名的成员变量 
	int age;		// 用于描述年龄的成员变量
	
	public static void main(String[] args) {
	// 声明Person类型的引用指向 创建Person类型的对象
	Person p = new Person();
	// 打印该对象的成员变量信息 null 0
	System.out.println("我是" + p.name + "，今年" + p.age + "岁了！");
	
	System.out.println("--------------------");
	// 修改成员变量的数值
	p.name = "zhangsan";
	p.age = 30;
	
	// 打印该对象的成员变量信息  zhangsan  30
	System.out.println("我是" + p.name + "，今年" + p.age + "岁了！");
	
	}
}
```

代码结果如下

```
我是null，今年0岁了！
--------------------
我是zhangsan，今年30岁了！
```



## 3.成员方法(重中之重)

#### 3.1 语法格式

​	class 类名 {

​		返回值类型  成员方法名 (形参列表) {

​			成员方法体;

​		}

​	}

如：

​	class Person {

​		void show() {

​			System.out.println("没事出来秀一下")；

​		}

​	}

**注意：**当成员变量名由多个单词组成时，通常要求从第二个单词起每个单词首字母大写。

#### 3.2 格式的详解

##### 	(1). 返回值类型

​	       返回值主要指从方法体内向方法体外返回的数据内容;

​	       返回值类型主要指返回值的数据类型，可以是基本数据类型，也可以是引用数据类型;

​	如：

​		当返回的数据内容是66时，则返回值类型写int即可;

​		当返回的数据内容是3.14时，则返回值类型写double即可;

​		当返回的数据内容是"he1lo"时，则返回值类型写String即可:

​	如:
​		当返回的数据内容是66时，则方法体中写:return66;

​		当返回的数据内容是num时，则方法体中写:returnnum;

​	若该方法不需要返回任何数据内容，则返回值类型写void即可。

##### 	(2). 形参列表

​		形式参数主要用于将方法体外的数据传入到方法体的内部，

​			格式:  数据类型  形参名 

​		形参列表主要指多个形式参数组成的整体，格式如下:

​			数据类型  形参名1，数据类型  形参名2，. . .

​		如:

​			当传入的数据内容是66时，则形参列表写为: int  i即可:

​			当传入的数据内容是3.14时，则形参列表写为: double  d即可;

​			当传入的数据内容是"he11o"时，则形参列表写为:  string s即可;

​			当传入的数据内容是66和"hello"时，则形参列表写为: int  i，String s即可;

​		若该方法不需要传入任何数据内容时，则形参列表位置啥也不写即可;

##### 	(3). 成员方法体

​		成员方法体主要编写描述该方法功能的语句。

​		如:
​			当该方法的功能就是打印时,则方法体中写 System.out.println("..."); 即可

​			当该方法的功能就是返回66时，则方法体中写return 66; 即可

#### 3.3 方法的调用

##### 	(1). 语法格式

​		引用变量名.成员方法名(实参列表);

​	如：

​		p.show();	表示使用引用变量p调用show方法

##### 	(2). 注意事项

​		I. 实际参数列表主要用于对形式参数列表进行初始化操作，因此参数的个数、类型
顺序等都必须与形参列表保持一致；

​		II. 实参可以传递直接量、变量、表达式以及方法的调用等;

###### 实例

```
public class Person {
	String name;	// 用于描述姓名的成员变量 
	int age;		// 用于描述年龄的成员变量
	public void show(){
		System.out.println("我是" + name + "，今年" + age + "岁了！");
	}
	
	public static void main(String[] args) {
	// 声明Person类型的引用指向 创建Person类型的对象
	Person p = new Person();
	// 打印该对象的成员变量信息 null 0
	p.show();
	
	System.out.println("--------------------");
	// 修改成员变量的数值
	p.name = "zhangsan";
	p.age = 30;
	
	// 打印该对象的成员变量信息  zhangsan  30
	p.show();
	
	}
}
```

##### 	(3). get、set方法

​		格式：get

​			数据类型 方法名 (){

​				return 参数名;

​			}

​		如：

​			String getName () {

​				return name;

​			}

​		格式：set

​			void 方法名 (数据类型 参数1){

​				this.参数2 = 参数1;

​			}

​		如：

​			void setName (string name1) {

​				this.name = name1;

​			}

###### 实例

```
public class Person {

    String name;	// 用于描述姓名的成员变量
    int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    // 用于描述年龄的成员变量
    public void show(){
        System.out.println("我是" + name + "，今年" + age + "岁了！");
    }

    public static void main(String[] args) {
        // 声明Person类型的引用指向 创建Person类型的对象
        Person p = new Person();

        p.setAge(40);
        p.setName("lisi");

        int age1 = p.getAge();
        String name1 = p.getName();
        System.out.println("获取到的姓名是:  " + name1 + " 获取到的年龄是： " + age1);
    }
}

```

代码结果如下

```
获取到的姓名是:  lisi 获取到的年龄是： 40
```



# 构造方法及方法重载

## 1. 构造方法和方法重载

​	如：

​		Person p = new Person( ); 	声明Person类型的引用指向Person类型的对象

​		show( );					 使用引用变量p调用show方法

#### 1.1 构造方法(重中之重)

##### 	(1). 语法格式

​		class 类名 {

​			类名(形参列表){

​				构造方法体；

​			}

​		}

​	如：

​		class Person {

​			Person() {

​			}

​		}

##### 	(2). 注意事项

​		I. 构造方法的名称与类名完全相同，没有返回值类型连void都不许有。

​		II. 当使用new关键字构造对象时会自动调用构造方法进行成员变量的初始化工作。

##### 	(3). 默认构造方法

​		I. 当一个类中没有自定义任何形式的构造方法时，编译器会自动添加一个无参的空构造方法，叫做默认/缺省构造方法，如:Person(){}

​		II. 若类中出现自定义构造方法，则编译器不再提供任何形式的构造方法

#### 1.2 方法的重载

##### 	(1). 基本概念

​		在Java语言中若方法的名称相同但参数列表不同，这样的方法之间构成重载关系

###### 实例

```
public class OverloadTest {
    void show(){
        System. out.println("show()");
    }
    void show(int i){ //ok 体现在参数的个数不同
        System.out.println("show(int)");
    }
    void show(int i,int j){ //ok 体现在参数的个数不同
        System.out.println("show(int,int)");
    }
    void show(int i,double d){ //ok 体现在参数的个数不同
        System.out.println("show(int,double)");
    }
    /*
    void show(int d,double i){ // error 与形参变量名无关
        System.out.println("show(int,double)");
    }
    */
    /*
    int show(){ // error 与返回值类型无关
        System.out.println("show");
    }
    */
    public static void main(String[] args){
        //声明本类类型的引用指向本类的对象
        OverloadTest ot = new OverloadTest();
        //调用成员方法
        ot.show();
        ot.show(66);
        ot.show(66,3.14);
        ot.show(66,289);
    }
}
```

##### 	(2). 体现形式

​		方法重载的主要形式有: 参数的个数不同、参数的类型不同、参数的顺序不同，与形参变量名和返回值类型无关，但建议返回值类型最好相同。

​		判断方法是否重载的核心: 调用能否区分。

##### (3). 实际意义

​	对于调用者来说只需要记住一个方法名就可以调用各种不同的版本实现不同的效果

如：

​	char c = "a" ;

​	System.out.println(c) ;

​	int i= 10 ;

​	System.out.println(i) ;

​	double d = 3.14 ;			

​	System.out.println(d) ;

​	. . .



## 2.this关键字(原理、理解)

#### 2.1 基本概念

​	(1). 在构造方法中this关键字代表当前正在构造的对象。

​	(2). 在成员方法中this关键字代表当前正在调用的对象。

###### 实例

```
public class ThisTest{
	ThisTest(){
		// 在构造方法中出现this代表当前正在构造的对象
		System.out.println("构造方法中: this = " + this);
	}
	void show(){
		// 在成员方法中出现this代表当前正在调用的对象		this相当于汉语的“我”
		System.out.println("成员方法中: this = " + this);
	}
	public static void main(String[] args){
		ThisTest tt = new ThisTest();
		tt.show();
		System.out.println("main方法中: tt = " + tt);
	}
	

}
	
```

​	(3). 原理分析:

​		当成员方法中访问成员变量时默认会加上this.(相当于汉语中"我的")，当不同的引用调用同一个成员方法时会导致成员方法中的this不同，那么this.访问的结果随之不同。

#### 2.2 使用方式

​	(1). 当形参变量和成员变量同名时，在构造方法或成员方法中通常优先使用形参变量，若希望使用成员变量就需要在变量名的前面加上this.进行说明(重中之重)。

​	(2). 在构造方法的第一行使用this(实参)的方式可以调用本类中的其它构造方法(了解)



## 3. 方法的传参和递归调用

#### 3.1 方法的传参过程(理解)

​	(1). main方法是程序的入口，为main方法中的局部变量开辟内存空间并初始化；

​	(2). 调用max方法时为max方法的形参变量开辟内存空间;

​	(3). 使用实参变量给形参变量进行赋值操作，执行max方法的方法体;

​	(4). 当max方法结束后释放形参变量的内存空间;

​	(5). main方法中的res得到max方法的返回值然后继续向下执行;

​	(6). 当main方法结束后释放局部变量的内存空间;

###### 实例

```
public class ArgumentTest {
    void show(int i){
        i = 200 ;
        System.out.println("i = " + i); // 200
    }
    public static void main(String[] args) {
        ArgumentTest at = new ArgumentTest();
        int num = 10;
        at.show(num);
        System.out.println("num = " + num); // 10 200
    }
}
```

​	(7). 要求掌握的内容:
​	I. 当基本数据类型的变量作为方法的参数传递时，形参变量的改变不会影响到实参;

​	II. 当引用数据类型的变量作为方法的参数传递时，形参变量指向的内容发生改变后会影响到实参变量指向的内容;

​	III. 当引用数据类型的变量作为方法的参数传递时，形参变量改变指向后再改变指向的内容时不会影响到实参变量指向的内容;

#### 3.2 递归调用

##### 	(1)基本概念

​		在一个方法体的内部调用当前方法自身的形式，叫做递归。

​	如：

​		void show() {

​			show();

​		}

​	案例：

​		自定义成员方法实现参数n阶乘的计算并返回。

​	解析：

​		5！=  5 * 4 * 3 * 2 * 1；

​		4！=  4 * 3 * 2 * 1；

​		3！=  3 * 2 * 1；

​		2！=  2 * 1；

​		1！=  1；

​		n!   =  n * (n-1) * (n-2) *  . . .  * 1;

​		

​		5！=  5 * 4! ；

​		4！=  4 * 3! ；

​		3！=  3 * 2! ；

​		2！=  2 * 1! ；

​		1！=  1 ；

​		n!   =  n * (n-1)!;

实例

```
public class JiechengTest {
	// 自定义成员方法实现参数n阶乘的计算并返回。
	int show(int n){
		if(1 == n){
			return 1;
		}
		return n * show(n-1);
	}
	public static void main(String[] args) {
		JiechengTest jt = new JiechengTest();
		int num = jt.show(5);
	}
}
```

##### 	(2). 注意事项

​		I. 必须找到递归的规律和退出条件;

​		II. 使用递归使得问题简单化而不是复杂化;

​		III. 若递归影响到程序的执行性能则使用递推取代之;



# 面向对象的封装特性和static关键字

## 1. 封装(重中之重)

#### 1.1 基本概念

​	(1). 通常情况下测试类可以对封装类中的成员变量进行赋值，若赋值的数据合法但不合理时，无论是编译阶段还是运行阶段都不会报错或者给出提示，此时与现实生活不符。

​	(2). 为了避免上述错误的发生，就需要对成员变量进行密封包装处理，该机制就叫做封装，换句话说，封装就是一种保证成员变量值合理性的机制。

###### 实例：实现Java封装的步骤

​	1. 修改属性的可见性来限制对属性的访问（一般限制为private）

```
public class Person {
    private String name;
    private int age;
}
```

​	这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。



​	2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。例如：

```
public class Person{
    private String name;
    private int age;

    public int getAge(){
      return age;
    }

    public String getName(){
      return name;
    }

    public void setAge(int age){
      this.age = age;
    }

    public void setName(String name){
      this.name = name;
    }
}
```

​	采用 **this** 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。

#### 1.2 实现流程

​	(1)私有化成员变量，使用private关键字修饰;

​	(2)提供公有的get和set方法，在方法体中进行合理值的判断;

​	(3)在构造方法中调用set方法进行合理值的判断;



## 2. static关键字(重点)

#### 2.1 基本概念

​	(1). 通常情况下成员变量隶属于对象层级，每创建一个对象就需要申请独立的内存空间来存放该对象独立的成员变量信息，若所有对象的某个成员变量数值完全一样却又单独存放会造成内存空间的浪费。

​	(2). 为了解决上述问题，则使用static关键字修饰成员变量，此时该成员变量由对象层级提升为类层级被所有对象共享，该成员变量随着类的加载准备就绪，与是否创建对象无关

​	(3). static 关键字也可以修饰成员方法，推荐使用  类名.  的方式访问。

#### 2.2 使用方式

​	(1). 在非静态的成员方法中既能访问非静态的成员也能访问静态的成员;

​		(成员: 成员变量 + 成员方法, 静态成员被所有对象共享)

​	(2). 在静态的成员方法中只能访问静态的成员不能访问非静态的成员;

​		(成员: 成员变量 + 成员方法，调用静态方法时可能还没有创建对象)

​	(3). 只有隶属于类层级被所有对象共享的内容才可以使用static修饰;

​		(不能滥用static关键字)

案例：

​	编程实现Singleton类的封装

```
public class Singleton {
	
	// 1. 私有化构造方法，使用private
	//private修饰构造方法表示该方法只能在本类的内部使用
	private Singleton() {}
	
	// 2. 提供本类类型的引用指向本类类型的对象
	private static Singleton sin = new Singleton();
	
	//3.提供公有的get方法负责将成员变量返回出去
	public static Singleton getInstance(){
		return sin:
	}
	
	
}
```

​	编程实现Singleton类的测试

```
public class SingletonTest {
	public static void main(String[] args) {
		
		// 声明Singleton类型的引用指向该类型的对象
		Singleton s1 = Singleton.getInstanse();
		Singleton s2 = Singleton.getInstanse();
		System.out.println(s1==s2); // true
	}
	
}
```

#### 2.3 单例设计模式(重中之重)

##### 	(1). 基本概念

​		在某些特殊场合中一个类对外提供且只提供一个对象，这样的类叫做单例类。

​		而设计单例类的思想和模式叫做单例设计模式，主要用于固定的场合。

##### 	(2). 实现流程

​		I. 私有化构造方法，使用private关键字修饰;

​		II. 声明本类类型的引用指向本类类型的对象，使用private static共同修饰;

​		III. 提供公有的get方法负责将成员变量的数值返回出去，使用static关键字修饰;

##### 	(3). 实现方式

​		单例设计模式的实现方式有两种: 饿汉式 和 懒汉式，在以后的开发中推荐饿汉式

```
public class Singleton {
	
	// 1. 私有化构造方法，使用private
	//private修饰构造方法表示该方法只能在本类的内部使用
	private Singleton() {}
	
	// 2. 提供本类类型的引用指向本类类型的对象
	private static Singleton sin = new Singleton(); // 饿汉式
	private static Singleton sin = null;			// 懒汉式
	
	//3.提供公有的get方法负责将成员变量返回出去
	public static Singleton getInstance(){
		return sin:
	}
	
	
}
```

#### 2.4 代码块

​	java允许直接 { } 写代码，叫代码块(了解)
​	写在类体中的代码块叫构造块，每创建一个对象，构造块都会被执行一次。
​	前面加static的构造块叫静态代码块，类加载时执行一次。



# 面向对象的继承特性和final关键字

## 1. 继承(重中之重)

#### 1.1 基本概念

​	当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而在多个类的内部编写自己独有特征和行为的方式叫做继承。

​	使用继承可以提高代码的复用性和扩展性以及可维护性。

​	在Java语言中使用**extends**(扩展)关键字来表达继承关系

如：

​	public class Student extends Person{ }	 - 表示Student类继承自Person类

​	其中Person类叫做基类、父类、超类

​	其中Student类叫做派生类、子类、孩子类

#### 1.2 注意事项

​	(1). 子类可以继承父类的成员变量和成员方法，其中私有成员变量可以继承但不可以直接使用，子类不可以继承父类的构造方法和私有方法。

​	(2). 无论使用何种方式构造子类对象时，都会自动调用父类中的无参构造方法来初始化从父类中继承下来的成员变量，相当于在子类构造方法第一行增加代码:super()的效果

​	(3). 使用继承必须满足 子类 is a 父类的逻辑关系，也就是不能滥用继承。

​	(4). Java语言中只支持单继承不支持多继承，也就是一个子类只能有一个父类，但一个

父类可以有多个子类。

实例

公共类：

```
public class Animal { 
    private String name;  
    private int id; 
    public Animal(String myName, int myid) { 
        name = myName; 
        id = myid;
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是"         + id + "号" + name + "."); 
    } 
}
```

企鹅类：

```
public class Penguin extends Animal { 
    public Penguin(String myName, int myid) { 
        super(myName, myid); 
    } 
}
```

老鼠类：

```
public class Mouse extends Animal { 
    public Mouse(String myName, int myid) { 
        super(myName, myid); 
    } 
}
```



1.3 方法的重写(override)

​	(1). 基本概念

​		若从父类中继承下来的方法不满足子类的需求时，就需要在子类中重新写一个与父类中方法一样的方法来覆盖从父类中继承的版本，这种方式就叫做重写。

​	(2)重写的原则(笔试题)

​		I. 要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型

​		II. 要求方法的访问权限不能变小，可以相同或者变大。

​		III. 要求不能抛出更大的异常(异常机制)。



## 2. 访问控制

#### 2.1 常用的访问控制符

|   修饰符    | 访问权限 | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |
| :---------: | :------: | :----: | -------- | :------------: | :------------: | :----: |
|  `public`   |  公有的  |   Y    | Y        |       Y        |       Y        |   Y    |
| `protected` | 受保护的 |   Y    | Y        |       Y        |      Y/N       |   N    |
|  `default`  |  默认的  |   Y    | Y        |       Y        |       N        |   N    |
|  `private`  |  私有的  |   Y    | N        |       N        |       N        |   N    |

(1). public修饰的内容可以在任意位置使用;

(2). private修饰的内容只能在本类中使用;

(3). 通常情况下，成员变量都使用private修饰，成员方法都使用public修饰;

#### 2.2 包的定义

​	package  包名；

​	package  包名1.包名2...包名n;	-便于管理，避免命名冲突的问题



## 3. final关键字(重点)

#### 3.1 基本概念

​	final本意为"最终的，不可更改的"，该关键字可以修饰类、成员方法、成员变量等。

#### 3.2 使用方式

​	final关键字修饰类表示该类不能被继承

​		为了防止滥用继承带来的危害

​		如:  `java.lang.String`类等

​	final关键字修饰成员方法表示该方法不能被重写但可以被继承。

​		为了防止不经意间造成的方法重写

​		如: `java.text.DateFormat`类中的format方法等

​	final关键字修饰成员变量表示该成员变量必须初始化而且不能更改。

​		为了防止不经意间造成数值的更改。

​		如: `java.lang.Thread`类中的MAX_PRIORITY等

​	扩展:

​		在开发中很少单独使用static关键字或final关键字修饰成员变量，通常都是使用public static final共同修饰成员变量来表达常量的含义，常量的命名规则是:  要求所有字母大写，不同单词之间采用下划线连接，

​		如:  public static final double Pl = 3. 14;





# 面向对象的多态特性及抽象类和接口

## 1. 多态

#### 1.1 基本概念

​	多态主要指同一种事物表现出来的多种形态。

​	饮料:  可乐、雪碧、脉动、乐虎、红牛、 . . .

​	宠物:  狗、猫、鸟、乌龟、鱼、. . .

​	人:  学生、教师、工人、. . .

#### 1.2 语法格式

​	父类类型 引用变量名=new 子类类型()
如:
​	`Person pw = new Worker();`

​	`pw.show();`

解析：

​	编译阶段调用Person类中show方法，在运行阶段调用Worker类中重写以后的show方法。

实例

​	编程实现Person类的封装，特征有:姓名和年龄，要求提供打印所有特征的行为。
​	编程实现Worker类的封装继承Person类，特征有:薪水。

```
public class Person {
    private String name;
    private int age;

    public Person() {
        super();
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age > 0 && age < 150) {
            this.age = age;
        } else {
            System.out.println("年龄不合理！");
        }

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Person(String name, int age) {
        super();
        setName(name);
        setAge(age);
    }

    public void show() {
//        System.out.println("我是父类的版本！！");
        System.out.println("我是" + getName() + "，今年" + getAge() + "岁");
    }
}
```

```
public class Worker extends  Person{
    private int salary;

    public Worker() {
        super();
    }
    public Worker(String name, int age, int salary){
        super(name, age);
        setsSalary( salary);
    }

    public int getsSalary() {
        return salary;
    }

    public void setsSalary(int salary) {
        if (salary >= 2120){
            this.salary = salary;
        } else {
            System.out.println("薪水不合理！！！");
        }

    }

    @Override
    public void show() {
        super.show();
        System.out.println("我的薪水是：" + getsSalary());
    }

}
```

```
public class PersonWorkerTest {
    public static void main(String[] args) {

        // 1.声明父类类型的引用指向父类类型的对象
        Person p = new Person("张三", 20);
        // 当子类没有重写show方法时，下面调用父类的show方法
        // 当子类重写show方法后，下面调用父类的show方法
        p.show();

        System.out.println("-----------------");
        // 2. 声明子类类型的引用，指向父类类型的对象
        Worker w = new Worker("李四", 30, 5000);
        // 当子类没有重写show方法时，下面调用父类的show方法
        // 当子类重写show方法后，下面调用子类的show方法
        w.show();

        System.out.println("-----------------");
        //3.声明父类类型的引用指向子类类型的对象，形成了多态
        // 子类 is a 父类
        Person pw = new Worker("王五", 40, 8000);
        // 当子类没有重写show方法时，下面调用父类的show方法
        // 当子类重写show方法后，下面调用子类的show方法
        pw.show();
    }

}
```

#### 1.3 多态的效果

​	(1). 当父类的引用指向子类的对象时，父类的引用可以直接调用父类独有的方法;

​	(2). 当父类的引用指向子类的对象时,父类的引用不可以直接调用子类独有的方法;

​	(3). 对于父子类都有的非静态成员方法来说，编译阶段调用父类版本，运行阶段调用子类重写以后的版本;
​	(4). 对于父子类都有的静态方法来说，编译和运行阶段调用父类版本，隶属于类层级,因此与指向的对象无关;

#### 1.4 引用数据类型之间的转换

​	(1).    引用数据类型之间的转换分为:自动类型转换和强制类型转换。

​		 其中自动类型转换主要指从小范围到大范围之间的转换，也就是子类到父类的转换

​	 	其中强制类型转换主要指从大范围到小范围之间的转换，也就是父类到子类的转换

​	(2). 引用数据类型之间的转换必须发生在父子类之间，否则编译报错。

​	(3). 若转换到的目标类型是子类类型但不是该引用真正指向的子类类型，则编译通过，运行阶段发生类型转换异常。

​	(4). 为了避免上述错误的发生，可以使用`instanceof`进行判断，具体格式如下:

​	if (引用变量名 `instanceof` 数据类型)   -  判断引用变量指向的对象是否为后面类型

#### 1.5 多态的意义

​	多态的实际意义在于可以屏蔽不同子类的差异性实现通用的编程，但可以调用不同的方法带来不同的结果。

#### 1.6 多态的使用场合：

​	I. 通过方法的参数传递形成多态

```
		public static void draw(Shape s) {}

		TestShape.draw (new Rect(1,2,3,4));
```

​	II. 在方法体中直接使用多态的语法格式

```
		TestAbstract ta = new SubTestAbstract();

		ta.show();
```



## 2. 抽象类

#### 2.1 抽象方法的概念

​	抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰

​	语法格式：

​		访问控制符 abstract 返回值类型 方法名称(形参列表)；

​	如：

​		public abstract void cry ( );

#### 2.2 抽象类的概念

​	抽象类就是指不能具体实例化的类，也就是不能创建对象并使用abstract关键字修饰

#### 2.3 注意事项

​	(1). 抽象类中可以有成员变量、构造方法以及成员方法;

​	(2). 抽象类中可以有抽象方法也可以没有抽象方法;

​	(3). 拥有抽象方法的类必须是抽象类，因此严格来说，具有抽象方法并且使用abstract关键字修饰的类才算真正意义上的抽象类。

#### 2.4 实际意义

​	抽象类的意义不在于自身创建对象而在于被继承，当一个类继承抽象类后必须重写抽象类中的抽象方法，否则该类也变成抽象类。

​	也就是说抽象类对子类具有强制性和规范性，因此叫做模板设计模式。

###### 实例

```
/* 文件名 : Employee.java */
public abstract class Employee
{
   private String name;
   private String address;
   private int number;
   public Employee(String name, String address, int number)
   {
      System.out.println("Constructing an Employee");
      this.name = name;
      this.address = address;
      this.number = number;
   }
   public double computePay()
   {
     System.out.println("Inside Employee computePay");
     return 0.0;
   }
   public void mailCheck()
   {
      System.out.println("Mailing a check to " + this.name
       + " " + this.address);
   }
   public String toString()
   {
      return name + " " + address + " " + number;
   }
   public String getName()
   {
      return name;
   }
   public String getAddress()
   {
      return address;
   }
   public void setAddress(String newAddress)
   {
      address = newAddress;
   }
   public int getNumber()
   {
     return number;
   }
}
```

```
/* 文件名 : AbstractDemo.java */
public class AbstractDemo
{
   public static void main(String [] args)
   {
      /* 以下是不允许的，会引发错误 */
      Employee e = new Employee("George W.", "Houston, TX", 43);
 
      System.out.println("\n Call mailCheck using Employee reference--");
      e.mailCheck();
    }
}
```

当你尝试编译 AbstractDemo 类时，会产生如下错误：

```
Employee.java:46: Employee is abstract; cannot be instantiated
      Employee e = new Employee("George W.", "Houston, TX", 43);
                   ^
1 error
```



## 3. 接口

#### 3.1 基本概念

​	接口就是一种比抽象类还抽象的类，体现为所有成员方法都是抽象方法。

​	定义类的关键字是class，而定义接口的关键字是interface。

​	继承类的关键字是extends，而实现接口的关键字是implements。

语法格式：

```
[修饰符] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
```

#### 3.2 类和接口之间的关系

​	类和类之间的关系		使用`extends`关键字表达继承的关系		支持单继承

​	类和接口之间的关系	    使用`implemets`关键字表达实现的关系	   支持多实现

​	接口和接口之间的关系	使用`extends`关键字表达继承的关系		支持多继承

#### 3.3 抽象类和接口之间的区别

​	(1). 定义抽象类的关键字是 `abstract class`，而定义接口的关键字是interface。

​	(2). 继承抽象类的关键字是 extends，而实现接口的关键字是implements。

​	(3). 继承抽象类支持单继承，而实现接口可以多实现。

​	(4). 抽象类中可以有构造方法，而接口中不可以有构造方法，

​	(5). 抽象类中可以有成员变量，而接口中只可以有常量。

​	(6). 抽象类中可以有成员方法，而接口中只可以有抽象方法。

​	(7). 抽象类中增加方法可以不影响子类，而接口中增加方法通常都影响子类。

​	(8). 从jdk1.8开始允许接口中出现非抽象方法，但需要使用default关键字修饰。



## 4. 内部类

#### 4.1 基本概念

​	当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类，而这个内部类所在的类叫做外部类

​	类中的内容:  成员变量、成员方法、构造方法、静态成员、构造块和静态代码块、内部类

#### 4.2 语法格式

​	class 外部类名{

​		class 内部类名 {

​			内部类的类体；

​		}

​	}

如：

​	class A{

​		class B {

​		}

​	}

#### 4.3 实际作用

​	当一个类存在的价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为所服务类中的内部类，这样可以隐藏该类的实现细节并且可以方便的访问外部类的私有成员而不再需要提供公有的get和set方法。

#### 4.4 基本分类

​	普通内部类  -  直接将一个类的定义放在另外一个类的类体中。

```
public class TestInner {
	private int cnt = 1;
	
	//在类体中定义一个普通内部类隶属于对象层级
	class Inner{
		void show(){
			System.out.println("cnt = " + cnt);
		}
	}
	public static void main(String[] args){
		// 声明外部类的引用指向外部类的对象
		TestInner ti = new TestInner();
		// 声明内部类的引用指向内部类的对象后调用show方法
		Inner in ti.new Inner();
		in.show();
	}
}
```

​	静态内部类  -  使用static关键字修饰的内部类，隶属于类层级。

```
public class TestInner {
	private int cnt = 1;
	private static int snt = 2;
	
	static class Inner{
		void show(){
			// System.out.println("cnt = " + cnt);//error静态成员中不能访问非静态
			System.out.println("snt = " + snt ); 
		}
	}
	public static void main(String[] args){
		// 声明静态内部类的引用指向静态内部类的对象
		TestInner ti = new TestInner();
		// 调用show方法
		in.show();
	}
}
```

局部内部类  -  直接将一个类的定义放在方法体的内部时

​			 作用范围是从声明开始一直到方法体结束

```
public class TestInner {
	
    
	public void show(){
		class Inner{
			void test() {
				System.out.println("局部内部类就是我所在的类!");
			}
		}
		Inner in = new Inner();
		in.test();
	}

	public static void main(String[] args){
		TestAreaInner tai = new TestAreaInner();
		tai.show();
	}
}
```



## 5. 匿名内部类(重点、难点)

#### 4.1 语法格式

​	接口/父类类型  引用变量名  =  new  接口/父类类型 ( )  class A { 方法的重写 } 

#### 4.2 经验分享

​	当接口类型的引用作为方法的形参时，实参的传递方式有两种:

​		I. 自定义类实现接口，然后创建该类的对象作为实参传递;

​		II. 使用匿名内部类的语法格式来得到接口类型的引用作为实参传递;
